#!/usr/bin/env python
# -*- coding: UTF8 -*-

# Python module pysdm.py
# Autogenerated from pysdm.glade
# Generated on Tue Aug 23 17:45:24 2005

# Warning: Do not modify any context comment such as #--
# They are required to keep user's code

import os
import gtk
import re

import constants
from blkid import *
from fstab import *

from SimpleGladeApp import SimpleGladeApp
from SimpleGladeApp import bindtextdomain

app_name = "pysdm"
app_version = "0.0.1"

glade_dir = ""
locale_dir = ""

bindtextdomain(app_name, locale_dir)

PARTITIONS = "/proc/partitions"
FSTAB = "/etc/fstab"
DEFAULT_MOUNT = "/media"


class Mainwindow(SimpleGladeApp):

    def __init__(self, path = os.path.join (constants.data_dir, "pysdm.glade"),
                 root="mainWindow",
                 domain=app_name, **kwargs):
        path = os.path.join(glade_dir, path)
        SimpleGladeApp.__init__(self, path, root, domain, **kwargs)

    #-- Mainwindow.new {
    def new(self):
        #Load fstab data
        self.fstab = Fstab(FSTAB)

        self.current_FS = None

        #Initializes partition tree
        ptree = self.get_widget("partitiontree")
        column = gtk.TreeViewColumn(_("Partition List"), gtk.CellRendererText(), text=0)
        ptree.append_column(column)
        self.refresh_partitions(self, None)

        self.get_widget("frame3").set_sensitive(False)

    #-- Mainwindow.new }

    #-- Mainwindow custom methods {
    def refresh_panel(self, partition):
        """
        Update General Information for the partition given

        partition:
            The name of the partition in /dev tree
        """
        filesystem = self.fstab.getFS("/dev/" + partition, None)
        name = re.split('/', filesystem.file)
        name = name[len(name)-1]

        name_entry = self.get_widget("name_entry")
        mountpoint_entry = self.get_widget("mountpoint_entry")
        type_entry = self.get_widget("type_entry")

        #Root filesystem cannot be modified
        self.get_widget("frame2").set_sensitive(True)
        if filesystem.file == "/":
            self.get_widget("frame3").set_sensitive(False)
        else:
            self.get_widget("frame3").set_sensitive(True)

        name_entry.set_text(name)
        mountpoint_entry.set_text(filesystem.file)
        type_entry.set_text(filesystem.vfstype)

        self.get_widget("status_bar").push(0, self.current_FS.spec)

  


    def load_options(self, vfstype):
        options = file(os.path.join(constants.data_dir,"fsdata/default")).readlines()
		
        try:
            options = options + file(os.path.join (constants.data_dir,"fsdata/" + vfstype)).readlines()
        except IOError:
            pass

        self.options_dict = {}
        options.sort()
        options_box = self.get_widget("options_box")
        options_entry_box = self.get_widget("options_entry_box")
        
        for child in options_box.get_children():
            options_box.remove(child)
        for child in options_entry_box.get_children():
            options_entry_box.remove(child)

        for option in options:
            parsed_option = re.compile("^(\w+)=?(\w+)?(\*)?").search(option).groups()
            option_name = parsed_option[0]
            option_default_entry = parsed_option[1]
            option_default = (parsed_option[2]!=None)

            check_button = gtk.CheckButton(option_name, use_underline=False)
            check_button.set_active(option_default)
            check_button.connect("toggled", self.on_option_changed)
    
            entry = gtk.Entry()
            if option_default_entry!=None:
                entry.set_text(option_default_entry)
            entry.connect("changed", self.on_option_changed)

            self.options_dict[option_name] = [check_button, entry]

            options_box.pack_start(check_button)
            options_entry_box.pack_start(entry)
        options_box.show_all()
        options_entry_box.show_all()

    
    def get_options(self):
        if self.get_widget("option_defaults").get_active():
            return ["defaults"]

        options_array = []

        for i in self.options_dict:
            if self.options_dict[i][0].get_active():
                option_value = i
                if len(self.options_dict[i][1].get_text()) > 0:
                    option_value = option_value + "=" + self.options_dict[i][1].get_text()
                options_array.append(option_value)

        return options_array


    def set_options(self, options_array):
        if re.match(options_array[0],"defaults")!=None:
            self.get_widget("option_defaults").set_active(True)
            return
        else:
             self.get_widget("option_defaults").set_active(False)

        for i in self.options_dict:
            self.options_dict[i][0].set_active(False)
            self.options_dict[i][1].set_text("")

        for option_value in options_array:
            parsed_option = re.compile("^(\w+)=?(\w+)?").match(option_value).groups()
            self.options_dict[parsed_option[0]][0].set_active(True)
            if parsed_option[1]!=None:
                self.options_dict[parsed_option[0]][1].set_text(parsed_option[1])


    def auto_configure(self, partition):
        """
        Autoconfirures a new partition

        partition:
            The name of the partition in /dev tree to autoconfigure

        TODO:
            - Detect filesystem and select options for it
        """
        vfstype = get_vfstype("/dev/" + partition)
        self.fstab.addFS(Filesystem("/dev/" + partition, DEFAULT_MOUNT + "/" + partition, vfstype, ["defaults"], "0", "0"))

        self.get_widget("option_defaults").set_active(True)



    def get_partitions(self):
        """
        Find the partitions in the system
        """

        partitions = []
        partitions_file = open(PARTITIONS, "r")
        lines = partitions_file.readlines()
        for line in lines[2:]:
            partition = re.split('\W+', line)[4]
            try:
                os.stat("/dev/" + partition)
                partitions.append(partition)
            except OSError:
                pass
        return partitions



    def on_option_changed(self, widget, *args):
        self.current_FS.mntops = self.get_options()
    #-- Mainwindow custom methods }





    #-- Mainwindow.refresh_partitions {
    def refresh_partitions(self, widget, *args):
        """
        Updates partition tree
        """

        ptree = self.get_widget("partitiontree")
        partitions = self.get_partitions()
        model = gtk.TreeStore(str)
        lastdevice = partitions[0]
        iter = model.append(None, (partitions[0],))

        for partition in partitions[1:]:
            device = partition[:len(partition)-1]
            if lastdevice != device:
                lastdevice = partition
                iter = model.append(None, (partition,))
            else:
                if is_mountable("/dev/" + partition):
                    model.append(iter, (partition,))

        ptree.set_model(model)       
    #-- Mainwindow.refresh_partitions }

    #-- Mainwindow.on_partitiontree_cursor_changed {
    def on_partitiontree_cursor_changed(self, widget, *args):
        ptree = self.get_widget("partitiontree")
        selection = ptree.get_selection()
        model, selected = ptree.get_selection().get_selected()

        #User has selected a device
        if len(ptree.get_selection().get_selected_rows()[1][0])==1: 
            return

        partition = model.get_value(selected, 0)

        #If exists a configuration in FSTAB
        if self.fstab.getFS("/dev/" + partition, None) != None:
            self.current_FS = self.fstab.getFS("/dev/" + partition, None)
            self.refresh_panel(partition)
            self.load_options(self.current_FS.vfstype)
            self.set_options(self.current_FS.mntops)
        else:
            ask_configure = gtk.Dialog(_("Configure now?"), self.main_widget, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, (gtk.STOCK_OK, gtk.RESPONSE_ACCEPT, gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT))
            ask_configure.vbox.pack_start(gtk.Label("\n" + partition + _(" hasn't been configured.\nDo you want to configure it now?\n")))
            ask_configure.show_all()
            result = ask_configure.run()
            ask_configure.destroy()
            if result == gtk.RESPONSE_ACCEPT:
                self.auto_configure(partition)
                self.current_FS = self.fstab.getFS("/dev/" + partition, None)
                self.refresh_panel(partition)
                self.load_options(self.current_FS.vfstype)
                self.set_options(self.current_FS.mntops)
            else:
                return

    #-- Mainwindow.on_partitiontree_cursor_changed }

    #-- Mainwindow.on_type_entry_changed {
    def on_type_entry_changed(self, widget, *args):
        if self.current_FS!=None:
            self.current_FS.vfstype = widget.get_text()
        
    #-- Mainwindow.on_type_entry_changed }

    #-- Mainwindow.on_name_entry_changed {
    def on_name_entry_changed(self, widget, *args):
        path = re.split("/", self.current_FS.file)
        npath = ""
        for folder in path[1:len(path)-1]:
            npath = npath + "/" + folder
        
        npath = npath + "/" +  widget.get_text()
        self.get_widget("mountpoint_entry").set_text(npath)
        
        self.current_FS.file = npath
    #-- Mainwindow.on_name_entry_changed }

    #-- Mainwindow.on_openmountpoint_clicked {
    def on_openmountpoint_clicked(self, widget, *args):
        filechooser = gtk.FileChooserDialog(_("Select a file for mountpoint..."), self.main_widget, action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, buttons=(gtk.STOCK_OPEN, gtk.RESPONSE_ACCEPT, gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT))
        filechooser.set_modal(True)
        filechooser.set_current_folder(DEFAULT_MOUNT)
        filechooser.show()
        response = filechooser.run()
        filechooser.hide()
        if response == gtk.RESPONSE_ACCEPT:
            self.get_widget("mountpoint_entry").set_text(filechooser.get_filename())
        self.current_FS.file = filechooser.get_filename()
        
        name = re.split('/', self.current_FS.file)
        name = name[len(name)-1]
        self.get_widget("name_entry").set_text(name)

        filechooser.destroy()
    #-- Mainwindow.on_openmountpoint_clicked }

    #-- Mainwindow.on_option_defaults_toggled {
    def on_option_defaults_toggled(self, widget, *args):
        self.get_widget("options_box").set_sensitive(not widget.get_active())
        self.get_widget("options_entry_box").set_sensitive(not widget.get_active())
        self.current_FS.mntops = self.get_options()
    #-- Mainwindow.on_option_defaults_toggled }

    #-- Mainwindow.on_apply_clicked {
    def on_apply_clicked(self, widget, *args):
        os.rename(FSTAB, FSTAB + ".BAK")
        for filesystem in self.fstab:
            try:
                os.mkdirs(filesystem.file)
            except OSError:
                pass
        self.current_FS.toFile(FSTAB)
    #-- Mainwindow.on_apply_clicked }


#-- main {

def main():
    main_window = Mainwindow()

    main_window.run()

if __name__ == "__main__":
    main()

#-- main }
