usage="""written to summarize the state of the system."""

import sys, pickle, pygsl #, sympy
import numpy as np
import network_flow as nf
import nmode_utils as nm_u
import mode_selection as ms
import pygsl.multifit_nlin as pygsl_mfN # fitting functions
import pygsl.errno as pygsl_errno

####################################################################################################
#
#
#                           basic statistic utilities
#
#
####################################################################################################
def sample_mean(x):
  """ compute sample mean """
  return sum(x)/len(x)

##################################################
def sample_var(x, xo=False):
  """ compute sample variance """
  if not xo:
    xo = sample_mean(x)
  return sum([(X-xo)**2 for X in x])/(len(x)-1)

##################################################
def outliers(x, y, z=3, rtol=1e-3, frac=0.75):
  """ 
  returns two lists generated by mean-finding with outlier rejection. The threshold for "outliers" is set by
  |x - xo| > z*s
  """
  n = len(y)
  if len(x) != n:
    sys.exit("x and y must have the same length in nmode_state.outliers()")

  old_m = sample_mean(y)
  old_s = sample_var(y, xo=old_m)**0.5

  (inX, inY), (TOToutX, TOToutY) = outlier_winnow(x,y,old_s,old_m,z)
  m = sample_mean(inY)
  s = sample_var(inY, xo=m)**0.5

  while 2*abs(old_m - m) > rtol*abs(old_m + m): # iterate until we agree to within rtol
    old_m = m
    old_s = s
    (_inX, _inY), (outX, outY) = outlier_winnow(inX,inY,old_s,old_m,z)
    if len(inX) < frac*n:
      break
    inX = _inX
    inY = _inY
    TOToutX += outX
    TOToutY += outY
    m = sample_mean(inY)
    s = sample_var(inY, xo=m)**0.5

  return (m, s), (inX, inY), (TOToutX, TOToutY)

##################################################
def outlier_winnow(x,y,s,m,z):
  """ separate elements of a list based on their deviation from "m" """
  inX  = []
  inY  = []
  outX = []
  outY = []
  for _x,_y in zip(x,y):
    if abs(_y-m) > z*s:
      outX.append(_x)
      outY.append(_y)
    else:
      inX.append(_x)
      inY.append(_y)

  return (inX, inY), (outX, outY)

#################################################
def gini_index(sortedX):
  """
  assumes sortedX is a sorted list of values and computes the gini index corresponding to the curve

  y[i] = \sum_{n=1}^{n=i} sortedX[n]

  assumes the data spans the abscissa from 0->1, so sortedX[0] <=> 0, sortedX[-1] <=> 1

  also assumes that data runs from small -> large
  """
  if len(sortedX) <= 1:
    raise StandardError("len(sortedX) must be > 1 in nmode_state.gini_index")

  # integrate using trapazoidal approximation
  g_ind = 0.0
  old_x = sortedX[0]
  for x in sortedX[1:]:
    g_ind += (old_x+x)/2.0
    old_x = x

  ### normalize curve and return gini index
  tri_area = 0.5*sum(sortedX)*(len(sortedX)-1)
  return 1 - g_ind/tri_area
  
####################################################################################################
#
#
#                             analytically expected behavior
#
#
####################################################################################################
def Ethrs(freq, network):
  """
  for each mode in network, computes all possible Ethrs from pairing present. Returns them in a similiar form to network.K

  This algorithm returns Ethrs only for daughter modes (defined as NOT the largest natural frequency in the network)

  expect freq to be a list of peak frequencies (observed), one for each mode in network

  This algorithm may also be inefficient...
  """

  Ethrs = []
  for m in range(len(network)):
    Ethrsm = []
    wm, ym, Um = network.wyU[m]
    abs_wm = abs(wm)
    for i, j, kmij in network.K[m]: # iterate over all possible couplings
      wi, yi, Ui = network.wyU[i]
      wj, yj, Uj = network.wyU[j]
      abs_wi = abs(wi)
      abs_wj = abs(wj)
      if (abs_wm > abs_wi) and (abs_wm > abs_wj): # parent mode
        Ethrsm.append( (m, i,j, kmij, ms.compute_Ethr(-freq[m], wi, wj, yi, yj, kmij) ) ) # minus sign due to FFT convention
      elif (abs_wm > abs_wi): # j is the parent
        Ethrsm.append( (j,i,m, kmij, ms.compute_Ethr(-freq[j], wm, wi, ym, yi, kmij) ) )
      elif (abs_wm > abs_wj): # i is the parent
        Ethrsm.append( (i,j,m, kmij, ms.compute_Ethr(-freq[i], wm, wj, ym, yj, kmij) ) )
      elif (abs_wi > abs_wj): # i is the parent
        Ethrsm.append( (i,j,m, kmij, ms.compute_Ethr(-freq[i], wm, wj, ym, yj, kmij) ) )
      else: # j is the parent
        Ethrsm.append( (j,i,m, kmij, ms.compute_Ethr(-freq[j], wm, wi, ym, yi, kmij) ) )

    Ethrsm.sort(key=lambda l: l[-1])
    Ethrs.append( Ethrsm )

  return Ethrs

##################################################
def threeMode_equilib(triple, freq, network, verbose=False):
  """
  computes the three mode equilibrium amplitudes for each triple in triples

  computes the amplitudes from explicit formulae in terms of network parameters. 

  this may be inefficient...
  """
  o, i, j, k = triple
  wo, yo, Uo = network.wyU[o]
  wi, yi, Ui = network.wyU[i]
  wj, yj, Uj = network.wyU[j]

  try:
    Uo = Uo[0][0] # assumes of forcing amplitude structure
  except IndexError:
    if verbose: print "mode %d has no linear driving term. Don't know how to compute the equilibrium. skipping..." % o
    return ((o,i,j), (0,0,0))

  do = wo - freq
  di = (freq + wi + wj)/(1 + yj/yi)
  dj = (freq + wi + wj)/(1 + yi/yj)

  Ao = ( (di*dj + yi*yj)/(wi*wj))**0.5 / (2*k)

  Ai_over_Aj = ((wi*yj)/(wj*yi))**0.5

  cos_D = (di/wi)*(Ai_over_Aj)/(2*k*Ao)
  sin_D = (yi/wi)*(Ai_over_Aj)/(2*k*Ao)

  D = angle_from_trig( cos_D, sin_D )

  X = do*cos_D + yo*sin_D

  if wo*k > 0: ### required to ensure AiAj is positive!
    AiAj = (Ao/(2*wo*k))*( X + ( X**2 + (wo*Uo/Ao)**2 - (do**2 + yo**2) )**0.5 )
  else:
    AiAj = (Ao/(2*wo*k))*( X - ( X**2 + (wo*Uo/Ao)**2 - (do**2 + yo**2) )**0.5 )

  Ai = (Ai_over_Aj*AiAj)**0.5
  Aj = Ai/Ai_over_Aj

  cos_Do = (do*Ao - 2*wo*k*AiAj*cos_D)/(wo*Uo)
  sin_Do = (yo*Ao - 2*wo*k*AiAj*sin_D)/(wo*Uo)

  Do = angle_from_trig( cos_Do, sin_Do )

  Di_plus_Dj = D - Do

  Di_minus_Dj = np.random.rand()*2*np.pi

  Di = 0.5*(Di_plus_Dj + Di_minus_Dj)
  Dj = 0.5*(Di_plus_Dj - Di_minus_Dj)

  return (o,i,j), (Ao, Ai, Aj), ((sin_Do, cos_Do), (np.sin(Di), np.cos(Di)), (np.sin(Dj), np.cos(Dj))), (do, di, dj)

  '''
  wo = abs(wo) ; wi = -abs(wi) ; wj = -abs(wj) ;

  O = abs(freq)
  do = wo - O
  di = (O + wi + wj)/(1 + yj/yi)
  dj = yj/yi * di

  yiyj = yi+yj
  didj = O+wi+wj #=di+dj

  ### amplitudes
  Ao2 = (yi*yj + di*dj)/(wi*wj*4*k**2) # = yi*yj/(4*k**2*wi*wj) * ( 1 + (didj/yiyj)**2 )
  AL2 =  ( wo*Uo )**2 / ( do**2 + yo**2 ) 

  if AL2 <= Ao2:
    return (o,i,j), (AL2**0.5, 0.0, 0.0), ((yo/(do**2+yo**2)**0.5, do/(do**2+yo**2)**0.5), (0.0, 1.0), (0.0, 1.0)), (do, 0.0, 0.0)

  Ai2 = (yj/-wj) * (yo*yiyj + do*abs(didj)) / (4*k**2*wo*yiyj) * ( 1 + ( 1 + (4*k**2*wi*wj*(do**2+yo**2)*yiyj**2)/(yi*yj*(yo*yiyj + do*abs(didj))**2)*(AL2 - Ao2)   )**0.5 )
  Aj2 = (wj*yi)/(wi*yj) * Ai2

  Ao = Ao2**0.5
#  Ai = Ai2**0.5
#  Aj = Aj2**0.5
  Ai = abs(Ai2)**0.5
  Aj = abs(Aj2)**0.5

  ### phases
  sin_delta = ( 1 + (didj/yiyj)**2 )**-0.5 # delta = delta_o+delta_i+delta_j
  cos_delta = ( 1 + (yiyj/didj)**2 )**-0.5

  sin_delta_o = do*Ao/(wo*Uo) - Ai*Aj/(Ao*Uo)*(di*dj/(wi*wj))**0.5
  cos_delta_o = yo*Ao/(wo*Uo) - Ai*Aj/(Ao*Uo)*(yi*yj/(wi*wj))**0.5

  ### there is a degeneracy between delta_i and delta_j, so we set delta_j = 0
  sin_delta_i = sin_delta*cos_delta_o - sin_delta_o*cos_delta
  cos_delta_i = cos_delta*cos_delta_o + sin_delta*sin_delta_o

  return (o,i,j), (Ao, Ai, Aj), ((sin_delta_o, cos_delta_o), (sin_delta_i, cos_delta_i), (0.0, 1.0)), (do, di, dj)
  '''

###
def angle_from_trig( cosAngle, sinAngle):
  """
  returns the angle from the cosine and sine, determining the correct quadrant
  """
  angle = np.arccos(cosAngle)

  if (sinAngle >= 0):
    return angle
  else:
    return 2*np.pi - angle 

###
def __threeMode_parents_from_daughters(O,Ai,Aj,(si,ci),(sj,cj),tuples,network):
  """
  computes what the parent amplitudes must be (in a non-standard integration variable) given the daughter amplitudes
  """
  parents = []
  for o,i,j,k in tuples:
    w,y,U = network.wyU[o]
    if len(U) > 1:
      raise ValueError, "don't know how to compute 3mode equilibrium when there is more than one harmonic in the linear tidal forcing"
    else:
      U = U[0][1]
    d = w - O
    r = w*U + 2*w*k*Ai*Aj*(ci*cj - si*sj)
    i = -2*w*k*Ai*Aj*(ci*sj + si*cj)

    norm = d**2 + y**2

    parents.append( [ (r*d - i*y)/norm , (r*y + i*d)/norm ] ) ### equilib amplitude

  return parents

###
def __threeMode_effective_equilib(O, xn, tuples, network):
  """
  computes the effective 3mode solution when there are multiple parents
  """
  if not isinstance(xn, np.ndarray):
    xn = np.array( xn )

  ### compute effective mode
  z     = np.zeros((2,),float)
  kz_z  = z[:]
  wz_kz = 0.0
  wz_Uz = 0.0
  dz_yz_z = np.zeros((2,),float)
  for x, (o,i,j,k) in zip(zn, tuples):
    w,y,U = network.wyU[o]
    d = w - O
    if len(U) > 1:
      raise ValueError, "don't know how to compute 3mode equilibrium when there is more than one harmonic in the linear tidal forcing"
    else:
      U = U[0][1]
    z       += x
    kz_z    += k*x
    wz_kz   += k*w
    wz_Uz   += w*U
    dz_yz_z += np.array( (x[0]*y - x[1]*d, x[0]*d + x[1]*y) )

  raise StandardError, "WRITE ME"
  """
  o, i, j, k = triple
  wo, yo, Uo = network.wyU[o]
  wi, yi, Ui = network.wyU[i]
  wj, yj, Uj = network.wyU[j]

  try:
    Uo = Uo[0][0] # assumes of forcing amplitude structure
  except IndexError:
    if verbose: print "mode %d has no linear driving term. Don't know how to compute the equilibrium. skipping..." % o
    return ((o,i,j), (0,0,0))

  wo = abs(wo) ; wi = -abs(wi) ; wj = -abs(wj) ;

  O = abs(freq)
  do = wo - O
  di = (O + wi + wj)/(1 + yj/yi)
  dj = yj/yi * di

  yiyj = yi+yj
  didj = O+wi+wj #=di+dj

  ### amplitudes
  Ao2 = (yi*yj + di*dj)/(wi*wj*4*k**2) # = yi*yj/(4*k**2*wi*wj) * ( 1 + (didj/yiyj)**2 )
  AL2 =  ( wo*Uo )**2 / ( do**2 + yo**2 )

  if AL2 <= Ao2:
    return (o,i,j), (AL2**0.5, 0.0, 0.0), ((yo/(do**2+yo**2)**0.5, do/(do**2+yo**2)**0.5), (0.0, 1.0), (0.0, 1.0)), (do, 0.0, 0.0)

  Ai2 = (yj/-wj) * (yo*yiyj + do*abs(didj)) / (4*k**2*wo*yiyj) * ( 1 + ( 1 + (4*k**2*wi*wj*(do**2+yo**2)*yiyj**2)/(yi*yj*(yo*yiyj + do*abs(didj))**2)*(AL2 - Ao2)   )**0.5 )
  Aj2 = (wj*yi)/(wi*yj) * Ai2

  Ao = Ao2**0.5
#  Ai = Ai2**0.5
#  Aj = Aj2**0.5
  Ai = abs(Ai2)**0.5
  Aj = abs(Aj2)**0.5

  ### phases
  sin_delta = ( 1 + (didj/yiyj)**2 )**-0.5 # delta = delta_o+delta_i+delta_j
  cos_delta = ( 1 + (yiyj/didj)**2 )**-0.5

  sin_delta_o = do*Ao/(wo*Uo) - Ai*Aj/(Ao*Uo)*(di*dj/(wi*wj))**0.5
  cos_delta_o = yo*Ao/(wo*Uo) - Ai*Aj/(Ao*Uo)*(yi*yj/(wi*wj))**0.5

  ### there is a degeneracy between delta_i and delta_j, so we set delta_j = 0
  sin_delta_i = sin_delta*cos_delta_o - sin_delta_o*cos_delta
  cos_delta_i = cos_delta*cos_delta_o + sin_delta*sin_delta_o

  return (o,i,j), (Ao, Ai, Aj), ((sin_delta_o, cos_delta_o), (sin_delta_i, cos_delta_i), (0.0, 1.0)), (do, di, dj)
  """


###
def deprecated_threeMode_equilib(triple, freq, network, verbose=False):
  """
  computes the three mode equilibrium amplitudes for each triple in triples

  this may be inefficient...
  """
  o, i, j, k = triple
  wo, yo, Uo = network.wyU[o]
  wi, yi, Ui = network.wyU[i]
  wj, yj, Uj = network.wyU[j]

  try:
    Uo = Uo[0][0] # assumes of forcing amplitude structure
  except IndexError:
    if verbose: print "mode %d has no linear driving term. Don't know how to compute the equilibrium. skipping..." % o
    return ((o,i,j), (0,0,0)) 


  wo = abs(wo) ; wi = -abs(wi) ; wj = -abs(wj) ;

  O = abs(freq)
  do = wo - O
  di = (O + wi + wj)/(1 + yj/yi)
  dj = yj/yi * di

  sin_d = yi/(yi**2 + di**2)**0.5
  cos_d = di/(yi**2 + di**2)**0.5

  Ao = ( (yi*yj + di*dj)/(wi*wj) )**0.5 / (2*k)

  sin_didj = ( Ao/(wo*Uo) )*(do*sin_d - yo*cos_d)
  if abs(sin_didj) > 1:
    return ((o,i,j), (0,0,0))
  cos_didj = ( 1 - sin_didj**2 )**0.5

  # require that Ai, Aj > 0
  Ai2_p = (yo*yj)/(wo*wj) * ( ( do/yo * ((di*dj)/(yi*yj))**0.5 +1 ) + 2*k*Uo * wo/yo * ( (wi*wj)/(yi*yj) )**0.5 * cos_didj ) / (2*k)**2
  Ai2_m = (yo*yj)/(wo*wj) * ( ( do/yo * ((di*dj)/(yi*yj))**0.5 +1 ) - 2*k*Uo * wo/yo * ( (wi*wj)/(yi*yj) )**0.5 * cos_didj ) / (2*k)**2
  if (Ai2_p > 0) and (Ai2_m > 0): # multiple allowed solutions
    if verbose: print "Warning! mutliple solutions found for triple (%d,%d,%d). Choosing lower energy solution" % (o,i,j)
    Ai = min(Ai2_p, Ai2_m)**0.5
  elif (Ai2_p < 0) and (Ai2_m < 0):
    if verbose: print "Warning! no solution found for triple (%d,%d,%d). skipping..." % (o,i,j)
    return ((o,i,j), (0, 0, 0)) 
  else: # only a single allowed solution
    Ai = max(Ai2_p, Ai2_m)**0.5

  Aj = ( (yi*wj)/(yj*wi) ) **0.5 * Ai
    
  return ((o,i,j), (Ao, Ai, Aj)) 

####################################################################################################
#
#
#                              summary information
#
#
####################################################################################################
def compute_A(q, Eo=1.):
  """
  reuturns amplitudes in q
  """
  Ao = Eo**0.5
#  return [ [ Ao*(Q[0]**2 + Q[1]**2)**0.5 for Q in q[m] ] for m in range(len(q))]

  if not isinstance(q, np.ndarray):
    q = np.array(q)

  return Ao*np.sum(q**2, axis=2)**0.5


##################################################
def compute_E(q, Eo=1):
  """
  returns energies in q
  """
#  return [ [ Eo*(Q[0]**2 + Q[1]**2) for Q in q[m] ] for m in range(len(q))]

  if not isinstance(q, np.ndarray):
    q = np.array(q)

  return Eo*np.sum(q**2, axis=2)

##################################################
def compute_S(E):
  """
  returns entropies using energies (E)
  """
  if not isinstance(E, np.ndarray):
    E = np.array(E)

  weights = E / np.outer(np.ones(len(E),float), np.sum(E, axis=0))

  logweights = np.zeros_like(weights, float)
  truth = weights > 0
  logweights[truth] = np.log(weights[truth])

  return -np.sum( weights*logweights , axis=0 )

##################################################
def compute_ddt_P_E_q(t_P, q, system, Eo=1.):
  """
  returns time derivatives of energies in q
  """
  N_m = len(system.network)
  dE = [[] for i in range(N_m)]
  tdE = []
  for ind, t_p in enumerate(t_P):
    qvec = []
    for modeNo in range(N_m):
      qvec += q[modeNo][ind]
    dqdt = nf.dqdt_no_NLT(t_p*system.Porb, qvec, system)
    de = 0.0
    for modeNo in range(N_m):
      ro, io = q[modeNo][ind]
      dro = dqdt[2*modeNo]
      dio = dqdt[2*modeNo+1]
      _de = 2*(ro*dro + io*dio)*Eo*system.Porb
      dE[modeNo].append( _de )
      de += _de

    tdE.append( de )

  return tdE, dE

##################################################
def compute_ddt_P_E_x(t_P, x, system, Eo=1.):
  """
  equivalent of compute_ddt_P_E_q but with x 
  """
  N_m = len(system.network)
  tdE = []
  dE = [[] for i in range(N_m)]
  for ind, t_p in enumerate(t_P):
    xvec = []
    for modeNo in range(N_m):
      xvec += x[modeNo][ind]
    dxdt = nf.dxdt_no_NLT(t_p*system.Porb, xvec, system)
    de = 0.0
    for modeNo in range(N_m):
      ro, io = x[modeNo][ind]
      dro = dxdt[2*modeNo]
      dio = dxdt[2*modeNo+1]
      _de = 2*(ro*dro + io*dio)*Eo*system.Porb
      dE[modeNo].append( _de )
      de += _de
    tdE.append( de )

  return tdE, dE


##################################################
def A_exp_fit(t_P, q, P=1., Eo=1.):
  """ 
  returns an exponential fit of amplitudes in q 
  we fit: log(A) = a*(t/P) + b ==> A = Ao*E^{y*(t/P)}
  assumes |q|^2*Eo = E
          P is the period of the orbit in seconds
  returns y and Ao in terms of the dimensional parameters P and Eo
  also returns a "reduced chi-squared" measure of the goodness of fit
  """
  t_P = np.array(t_P)
  A = compute_A(q, Eo=Eo)
  S = len(t_P)
  St = sum(t_P)*P
  Stt = sum([t**2. for t in t_P])*P**2
  det = St**2 - S*Stt

  A_fit = []
  y_fit = []
  chi2_red = []
  array_t = np.array(t_P)*P
  for m in range(len(q)):
    array_Am = np.array(A[m])
    Sq = sum( np.log(array_Am) )
    Sqt = sum( np.log(array_Am)*array_t )
    _y_fit = (St*Sq - S*Sqt)/det # decay constant
    _b = (St*Sqt - Stt*Sq)/det # log of Amplitude at time = 0
    _chi2_red = sum( (array_Am - (_y_fit*t_P*P + _b))**2 / abs(_y_fit*t_P*P + _b) )/S

    y_fit.append( _y_fit )
    A_fit.append( np.exp( _b )*np.exp( y_fit[-1]*array_t[-1]) ) # return amplitude at end to time period 
    chi2_red.append( _chi2_red )

  return A_fit, y_fit, chi2_red

##################################################
def phase_lag(t_P, q, network, Eo=1):
  """
  returns the parent lag angle and parent amplitude compared to the driving frequency (P)
  we assume q_a = A_a e^{-i*\phi_a}
  we compute Im{q_a*e^{+i*m*\Omega*t}} = A_a \sin(2*np.pi*m*t/Porb - \phi_a)

  assume |q|^2*Eo = E
  """
  Ao = Eo**0.5
  N_m = len(q)
  qtilde = [[] for ind in range(N_m)]
  Asin_lag = [[] for ind in range(N_m)]
  sin_lag = [[] for ind in range(N_m)]
  A = compute_A(q, Eo=Eo)
  for ind, t_p in enumerate(t_P):
    for m, Q in enumerate(q):
      phs = 2*np.pi*t_p*network.modes[m].m
      cos_t = np.cos(phs)
      sin_t = np.sin(phs)
      R, I = Q[ind]
      __Asin_lag = Ao*(R*sin_t + I*cos_t)
      qtilde[m].append( [Ao*(R*cos_t - I*sin_t), __Asin_lag] )
      Asin_lag[m].append( __Asin_lag )
      sin_lag[m].append( __Asin_lag / A[m][ind] )

  return Asin_lag, sin_lag

##################################################
def viscous_disp(q, network, Eo=1.):
  """ 
  computes \sum_i {-2*y_i*E_i}
  returns the network total as well as the value for each mode

  network is an instance of networks.network
  """
  E = compute_E(q, Eo=Eo)
  N_m = len(E)
  tot_yE = []
  yE = [[] for m in range(N_m)]

  Y = [mode.y for mode in network.modes]
  for ind in range(len(E[0])):
    __tot_yE = 0
    for m in range(N_m):
      __yE = -2*Y[m]*E[m][ind]
      yE[m].append(__yE)
      __tot_yE += __yE
    tot_yE.append(__tot_yE)

  return tot_yE, yE

##################################################
def broken_PowLaw_fitter(x, y, sigma, max_iters=50, rtol=1e-8, verbose=False):
  """
  fits the data with 
    y = A * x**(-alpha) * ((1 + exp(x/beta))/2)**(-gamma)
  attempting no more than "max_iters" times to converge

  return _fit_params, [covar[i][i] for i in range(len(covar))], red_chi2
  """
  x = np.array(x)
  y = np.array(y)

  n = len(x) # number of data points
  p = 4 # number of fitting parameters

  ### set up system
  mysys = pygsl_mfN.gsl_multifit_function_fdf(    broken_PowLaw_fit,     broken_PowLaw_dfit,     broken_PowLaw_fitdfit, np.array( [x, y, sigma] ), n, p)
  solver = pygsl_mfN.lmsder(mysys, n, p)

  ### find starting point for parameters
  alpha = 0.75
  beta = len(x)*0.8
  gamma = beta/20
  A = y[0] * 0.8

  fit_params_guess = [A, alpha, beta, gamma]  # guess for fit parameters
  solver.set(fit_params_guess) 

  if verbose: 
    print "# %5s %9s %9s  %9s  %9s  %10s" % ("iter", "A", "alpha", "beta", "gamma", "|f(x)|")
    print "  %5d % .7f % .7f  % .7f  %.7f" % tuple( [0]+fit_params_guess ) # report initial guess

  for iter in range(1,max_iters+1):
    status = solver.iterate() # move fit params
    _fit_params = solver.getx() # new guess
    dfit_params = solver.getdx() # change in fit params
    fits = np.array( solver.getf() ) # residuals at every data point

    J = solver.getJ() # jacobian of fit
    tdx = pygsl_mfN.gradient( J, fits ) # gradient at fit
    status = pygsl_mfN.test_delta(dfit_params, _fit_params, rtol, rtol) # just copied, not understood...

    fn = np.sum((fits/sigma)**2)**0.5 # sum square errors
    if status == pygsl_errno.GSL_SUCCESS:
      if verbose: print "# Converged :"
      break
    if verbose: print "  %5d % .7f % .7f  % .7f  % .7f  % .7f" % tuple([iter] + list(_fit_params) + [fn]) # report state
  else:
    if verbose:
      print "WARNING! Number of Iterations exceeded in nmode_state.broken_PowLaw_fitter!"
      print "continuing with best guess after %d iterations" % max_iters

  # get error bars on fit params
  covar = pygsl_mfN.covar(solver.getJ(), 0.0) # covariance matrix
  red_chi2 = 1.0*sum( (broken_PowLaw(x, _fit_params) - y)**2 / y )/len(x)
  if verbose:
    print "#    A   = % .5f +/- % .5f" % (_fit_params[0], covar[0,0])
    print "# alpha  = % .5f +/- % .5f" % (_fit_params[1], covar[1,1])
    print "#  beta  = % .5f +/- % .5f" % (_fit_params[2], covar[2,2])
    print "# gamma  = % .5f +/- % .5f" % (_fit_params[3], covar[3,3])
    print "# red_chi2 = % .6f" % red_chi2

  return _fit_params, [covar[i][i] for i in range(len(covar))], red_chi2


#########################
def broken_PowLaw(x, fit_params):
  """
  returns A * x**(-alpha) * ( (1+exp(x/beta))/2 )**(-gamma) 
  """
  A, alpha, beta, gamma = fit_params

  return A * x**(-alpha) * (1+np.exp(x/beta)/2)**(-gamma) 

#########################
def broken_PowLaw_dfit(fit_params, data):
  """
  returns the derivative of the fits with respect to fit parameters at each point
  """
  A, alpha, beta, gamma = fit_params
  x, y , s = data

  dfitdA     = ( x**(-alpha) * (1+np.exp(x/beta)/2)**(-gamma) )/s 
  dfitdalpha = ( A * x**(-alpha)*(-np.log(x)) * (1+np.exp(x/beta)/2)**(-gamma) )/s 
  dfitdbeta  = ( A * x**(-alpha+1) * (gamma/(2*beta**2)) * (1+np.exp(x/beta)/2)**(-gamma-1) )/s
  dfitdgamma = ( A * x**(-alpha) * (1+np.exp(x/beta)/2)**(-gamma)*(-np.log(1+np.exp(x/beta)/2)) )/s

  dfit = np.array([dfitdA, dfitdalpha, dfitdbeta, dfitdgamma])
  return dfit.transpose()

#########################
def broken_PowLaw_fit(fit_params, data):
  """
  a helper function that returns the residuals between the fit and the data
  """
  x, y , s = data

  return (broken_PowLaw(x, fit_params) - y) / s

#########################
def broken_PowLaw_fitdfit(fit_params, data):
  """
  return broken_PowLaw_fit(fit_params, data), broken_PowLaw_dfit(fit_params, data)
  """
  return broken_PowLaw_fit(fit_params, data), broken_PowLaw_dfit(fit_params, data)

####################################################################################################
#
#
#                      frequency identification methods
#
#
####################################################################################################
def wavelet_lowpass(x, wavelet="db6", n=1):
  """
  throws out the n-th detail coefficient and reconstructs the series using the wavelet decomposition specified by wavelet
  """
  import pywt

  decomp = [(x,)]
  for ind in range(1,n+1):
    ac, dc = pywt.dwt(decomp[ind-1][0], wavelet)
    decomp.append( (ac, dc) )
  
  for ind in range(n):
    ac = pywt.idwt(ac, np.zeros((len(decomp[n-ind][1]),)), wavelet, correct_size=True)

  return ac


##################################################
def find_freq_peaks(freq, fq, delta=0, __sort=False, n_lowpass=False):
  """
  wrapper for a simple peak finding algorithm

  if n_lowpass is supplied, it should be the number of generations of smoothing using wavelets
  """
  psd_q = [ [ Q[0]**2 + Q[1]**2 for Q in fq[m] ] for m in range(len(fq)) ]
  maxs = []
  mins = []
  for m in range(len(psd_q)):
    peaks, min_peaks = nm_u.peakdet(psd_q[m], x=freq, delta=delta, n_lowpass=n_lowpass)
    if __sort:
      peaks.sort(key=lambda line: line[1], reverse=True)
      min_peaks.sort(key=lambda line: line[1])
    maxs.append(peaks)
    mins.append(min_peaks)

  return maxs, mins

##################################################
def contiguous_bunches(x,y,dx):
  """
  separates the data contained in x, y into bunches. Within each bunch, the data is expected to have the form

  x_{i+1} - x_{i} = dx
  """
  data = zip(x,y)

  if len(x) < 2:
    data

  data.sort(key=lambda l: l[0])

  old_x, old_y = data[0]
  bunchX = [old_x]
  bunchY = [old_y]

  bunches = []
  for _x, _y in data[1:]:
    if _x-old_x != dx:
      bunches.append( (bunchX, bunchY) )
      bunchX = [_x]
      bunchY = [_y]
    else:
      bunchX.append(_x)
      bunchY.append(_y)
    old_x = _x
    old_y = _y

  bunches.append( (bunchX, bunchY) )

  return bunches

##################################################
def fit_peaks_lorentzian(freq, fft_q, max_iters=100, z=1, outlier_rtol=1e-10, frac=0.5, fit_rtol=1e-8, verbose=False):
  """
  determines peaks using an ''outlier rejection'' algorithm (outliers()) and then groups outliers into contiguous bunches

  outlier rejection should help determine the subset of data belonging to each peak. This may break down for non-trivial psd's (unlikely to observe these for ~steady state modal networks)
  """
  psd_q = [ [ Q[0]**2 + Q[1]**2 for Q in fft_q[m]] for m in range(len(fft_q))]
  dfreq = freq[1]-freq[0]

  fit_params = []
  fit_params_covar = []

  for psd in psd_q: # iterate through for each mode
    (_, _), (TOTinX, _), (TOToutX, TOToutY) = outliers(freq, psd, z=z, rtol=outlier_rtol, frac=frac)
    print len(psd), len(TOTinX), len(TOToutX)

    bunches = contiguous_bunches(TOToutX, TOToutY, dfreq)

    print len(bunches)

    these_fit_params = []
    these_fit_params_covar = []

    for subset_freq, subset_psd_q in bunches:
      if len(subset_freq) <= 3:
        if verbose: print "WARNING: not enough data surrounding this subset (%d points around %f). Likely to see an error, so we skip this peak." % (len(subset_freq), subset_freq[0])
        continue

      _fit_params, _fit_params_covar = lorentzian_fitter(subset_freq, subset_psd_q, max_iters=50, rtol=fit_rtol, verbose=verbose)

      these_fit_params.append( _fit_params )
      these_fit_params_covar.append( _fit_params_covar )

    fit_params.append(these_fit_params)
    fit_params_covar.append(these_fit_params_covar)

  return fit_params, fit_params_covar

##################################################
def lorentzian_fitter(subset_freq, subset_psd_q, max_iters=50, rtol=1e-8, verbose=False):
  """
  fits subset_psd_q to the functional form

    A / ( (subset_freq - fo)**2 + Y**2 )

  attemps to fit at most max_iters times
  declares success if converged to within rtol

  assumes subset_freq, subset_psd_q are already sorted
  """

  # find a starting guess for the peak
  f_p = zip(subset_freq, subset_psd_q)
  f_p.sort(key=lambda l: l[1], reverse=True)
  f_p, psd_peak = f_p[0]

  subset = np.array( [np.array(subset_freq), np.array(subset_psd_q)] )

  n = len(subset[0]) # number of data points
  p = 3 # number of fitting parameters

  mysys = pygsl_mfN.gsl_multifit_function_fdf(lorentzian_fit, lorentzian_dfit, lorentzian_fitdfit, subset, n, p)
  solver = pygsl_mfN.lmsder(mysys, n, p)

  fit_params_guess = (f_p, 1e-5, psd_peak) # guess for starting point: fo, Y, A
  solver.set(fit_params_guess)

  if verbose: print "# %5s %9s %9s  %9s    %10s" % ("iter", "fo", "Y", "A", "|f(x)|")
  for iter in range(1,max_iters+1): # iterate solver
    status = solver.iterate() # move fit parameters
    _fit_params  = solver.getx() # new guess for fit params
    dfit_params = solver.getdx() # change in fit params
    fits  = np.array(solver.getf()) # residuals at every data point between data and fit

    J  = solver.getJ() # jacobian of the fit?
    tdx = pygsl_mfN.gradient(J, fits) # gradient of the fit?
    status = pygsl_mfN.test_delta(dfit_params, _fit_params, rtol, rtol)

    fn = np.sum(fits*fits)**0.5 # sum of squares of the residual
    if status == pygsl_errno.GSL_SUCCESS:
      if verbose: print "# Convereged :"
      break
    if verbose: print "  %5d % .7f % .7f  % .7f  % .7f" %(iter, _fit_params[0], _fit_params[1], _fit_params[2], fn) # report state
  else:
    if verbose:
      print "WARNING! Number of Iterations exceeded in nmode_state.lorentzian_fitter!"
      print "\tmodeNo=%d , peak_freq=%f, peak_psd=%f" % (m, f_p, psd_peak)
      print "continuing with best guess after %d iterations" % max_iters

  # get error bars on the fit parameters
#  J = solver.getJ() # not needed?
  covar =  pygsl_mfN.covar(solver.getJ(), 0.0) # covarience matrix
  if verbose:
    print "# fo = % .5f +/- % .5f" % (_fit_params[0], covar[0,0])
    print "# Y  = % .5f +/- % .5f" % (_fit_params[1], covar[1,1])
    print "# A  = % .5f +/- % .5f" % (_fit_params[2], covar[2,2])

  return _fit_params, [covar[0][0], covar[1][1], covar[2][2]]

##################################################
def __fit_peaks_lorentzian(freq, fft_q, max_iters=50, delta=0, verbose=False, rtol=1e-8):
  """
  fits a lorentzian to each peak of the PSD of q
  currently, we naively find peaks by searching for local maxima
    the fitting-subset of data is selected by using half the data between the peak and the nearest local minimum
      --> THIS MAY BE FRAGILE

  assumes freq, fft_q are sorted in order of increasing frequency
  """
  psd_q = [ [ Q[0]**2 + Q[1]**2 for Q in fft_q[m]] for m in range(len(fft_q))]
  fit_params = []
  fit_params_covar = []
  for m in range(len(psd_q)): # iterate through for each mode
    peaks, min_peaks = nm_u.peakdet(psd_q[m], x=freq, delta=delta, n_lowpass=n_lowpass) # find peaks/minima

    peaks.sort(key=lambda line: line[0]) # sort peaks by their frequencies
    min_peaks.sort(key=lambda line: line[0])
    min_peaks.insert(0, (freq[0], psd_q[0])) # add end points to min_peaks for data subset determination)
    min_peaks.append((freq[-1], psd_q[-1]))

    mfit_params = [] # store the best-fit parameters
    mfit_params_covar = []

    # set up fitting data set surrounding each peak
    min_freq = min(freq)
    max_freq = max(freq)
    min_peaks_ind = 0

    freq_min_ind = 0
    freq_max_ind = 0
    for peak in peaks:
      f_p , psd_peak = peak
#      print "    f*P=%f, PSD=%f" % (peak)
      while min_peaks[min_peaks_ind][0] < f_p: # find the nearest local minima to f_p
        min_freq = min_peaks[min_peaks_ind][0]
        min_peaks_ind += 1

      freq_min = max(min(f_p-bw, 0.5*(min_freq + f_p)), freq[0])
      freq_max = min(max(f_p+bw, 0.5*(f_p + min_peaks[min_peaks_ind][0])), freq[-1])

      print f_p-bw, freq_min, f_p, freq_max, f_p+bw

      subset_freq = []
      subset_psd_q = []
      while freq[freq_min_ind] < freq_min: # locate the proper subset of data
        freq_min_ind += 1
      freq_max_ind = freq_min_ind
      while (freq[freq_max_ind] < freq_max) and (freq_max_ind < len(freq)):
        subset_freq.append(freq[freq_max_ind]) # add points to the subset
        subset_psd_q.append(psd_q[m][freq_max_ind])
        freq_max_ind += 1
      freq_min_ind = freq_max_ind # start off at this point for the next peak

      if len(subset_freq) <= 3:
        if verbose: print "WARNING: not enough data surrounding this subset. Likely to see an error, so we skip this peak."
        continue
      subset = np.array( [np.array(subset_freq), np.array(subset_psd_q)] )

      n = len(subset[0]) # number of data points
      p = 3 # number of fitting parameters

      mysys = pygsl_mfN.gsl_multifit_function_fdf(lorentzian_fit, lorentzian_dfit, lorentzian_fitdfit, subset, n, p)
      solver = pygsl_mfN.lmsder(mysys, n, p)

      fit_params_guess = (f_p, 1e-5, psd_peak) # guess for starting point: fo, Y, A
      solver.set(fit_params_guess)

      if verbose: print "# %5s %9s %9s  %9s    %10s" % ("iter", "fo", "Y", "A", "|f(x)|")
      for iter in range(1,max_iters+1): # iterate solver
        status = solver.iterate() # move fit parameters
        _fit_params  = solver.getx() # new guess for fit params
        dfit_params = solver.getdx() # change in fit params
        fits  = np.array(solver.getf()) # residuals at every data point between data and fit

        J  = solver.getJ() # jacobian of the fit?
        tdx = pygsl_mfN.gradient(J, fits) # gradient of the fit?
        status = pygsl_mfN.test_delta(dfit_params, _fit_params, rtol, rtol)

        fn = np.sum(fits*fits)**0.5 # sum of squares of the residual
        if status == pygsl_errno.GSL_SUCCESS:
          if verbose: print "# Convereged :"
          break
        if verbose: print "  %5d % .7f % .7f  % .7f  % .7f" %(iter, _fit_params[0], _fit_params[1], _fit_params[2], fn) # report state
      else:
        if verbose:
          print "WARNING! Number of Iterations exceeded in nmode_state.fit_peaks_lorentzian!"
          print "\tmodeNo=%d , peak_freq=%f, peak_psd=%f" % (m, f_p, psd_peak)
          print "continuing with best guess after %d iterations" % max_iters

      # get error bars on the fit parameters
#      J = solver.getJ() # not needed?
      covar =  pygsl_mfN.covar(solver.getJ(), 0.0) # covarience matrix
      if verbose:
        print "# fo = % .5f +/- % .5f" % (_fit_params[0], covar[0,0])
        print "# Y  = % .5f +/- % .5f" % (_fit_params[1], covar[1,1])
        print "# A  = % .5f +/- % .5f" % (_fit_params[2], covar[2,2])

      mfit_params.append(_fit_params)
      mfit_params_covar.append([covar[0][0], covar[1][1], covar[2][2]])

    fit_params.append(mfit_params)
    fit_params_covar.append(mfit_params_covar)

  return fit_params, fit_params_covar

#########################
def lorentzian(f, fo=0, Y=1., A=1.):
  """
  return A / ( (f-fo)**2 + Y**2 )
  """
  return A/((f-fo)**2 + Y**2)

#########################
def lorentzian_fit(fit_params, data):
  """
  a helper function returning the residuals between fit and data
  """
  fo, Y, A = fit_params
  f, fft = data
  return (lorentzian(f, fo=fo, Y=Y, A=A) - fft)

#########################
def lorentzian_dfit(fit_params, data):
  """
  returns the derivatives of fit with respect to parameters at each point in data
  """
  fo, Y, A = fit_params
  f, fft = data
  f = np.array(f)

  dfitdA = ((f-fo)**2 + Y**2)**-1
  dfitdfo = 2*A*(f-fo)*fo*dfitdA**2
  dfitdY = -2*A*Y*dfitdA**2

  dfit = np.array([dfitdfo, dfitdY, dfitdA])
  return dfit.transpose()

#########################
def lorentzian_fitdfit(fit_params, data):
  """
  return lorentzian_fit(fit_params, data), lorentzian_dfit(fit_params, data)
  """
  return lorentzian_fit(fit_params, data), lorentzian_dfit(fit_params, data)

####################################################################################################
#
#
#                               Neutron star internal Hamiltonian
#
#
####################################################################################################
def Hns_q(q, network, Eo=1.0):
  """
  computes the neutron star's internal Hamiltonian

  Without damping, this Hamiltonian is conserved and is the energy of the system (modulo Eo, which is the mode amplitude normalization)

    H = \sum_{a} [ |q_a|**2 ] + \sum_{abc} [ (1/3)*k_{abc}*(q_a*q_b*q_c + c.c) ] 
      = \sum_{a} [R_a**2 + I_a**2 ] + (2/3)*\sum_{abc} [ k_{abc} (R_a*R_b*R_c - R_a*I_b*I_c - I_a*R_b*I_c - I_a*I_b*R_c) ]

  note, in this formulation the cannonical momentum for q_a is

    p_a = conjugate(q_a)/(-i*w_a)

  ALSO: the algorithm used to compute this is pretty brute force and can probably be optimized if it becomes prohibitively slow
  """
  N_m = len(network)

  Hns = [] # holder for computed Hamiltonian
  for ind in range(len(q[0])):
    h = 0.0 # hamiltonian at this time 
    for m in range(N_m): # iterate over all modes
      rm, im = q[m][ind]
      h += rm**2 + im**2 # linear component
      for i,j,k in network.K[m]: # sum over 3mode couplings
        if i == j:
          ri, ii = q[i][ind]
          h -= (2./3)*k*(rm*ri*ri - rm*ii*ii - im*ri*ii - im*ii*ri)
        else:
          ri, ii = q[i][ind]
          rj, ij = q[j][ind]
          h -= (4./3)*k*(rm*ri*rj - rm*ii*ij - im*ri*ij - im*ii*rj) # factor of 2 comes from interchange of i <--> j

    Hns.append( h*Eo )
  
  return Hns

#########################
def Hns_x(t_P, x, system, Eo=1.0):
  """
  the equivalent of Hns_q but using x.
  """
  network = system.network
  N_m = len(network)

  Hns = []
  for ind, t_p in enumerate(t_P):
    t = t_p*system.Porb

    h = 0.0
    for o in range(N_m):
      ro, io = x[o][ind]
      h += ro**2 + io**2 # linear component

      wo = network.wyU[o][0]
      for i,j,k in network.K[o]:
        if i == j:
          ri, ii = x[i][ind]
          wi = network.wyU[i][0]
          h -= (2./3)*k*( np.cos((wo+wi+wi)*t)*(ro*ri*ri - ro*ii*ii - io*ri*ii - io*ii*ri) + np.sin((wo+wi+wi)*t)*(ro*ri*ii + ro*ii*ri + io*ri*ri - io*ii*ii) )
        else:
          ri, ii = x[i][ind]
          wi = network.wyU[i][0]
          rj, ij = x[j][ind]
          wj = network.wyU[j][0]
          h -= (4./3)*k*( np.cos((wo+wi+wj)*t)*(ro*ri*rj - ro*ii*ij - io*ri*ij - io*ii*rj) + np.sin((wo+wi+wj)*t)*(ro*ri*ij + ro*ii*rj + io*ri*rj - io*ii*ij) )

    Hns.append( h*Eo )

  return Hns

#########################
def Hns_coup_q(q, network, coup=False, Eo=1.):
  """
  computes the energies associated with each coupling in the network. 
  Returns a dictionary with time series for each coupling

  if coup is supplied, it must be a list of couplings [(modeNo1,modeNo2,modeNo3), ...]
  else: coup is computed to be all couplings in the network
  """
  if not coup:
    coup = []
    for c in network.gens()[-1]:
      coup += c

  num_pts = len(q[0])
  Hns_coup = {}
  for o,i,j,k in coup: # iterate over all couplings
    Hns = []

    if (o == i) and (o == j):
      for ind in range(num_pts): # iterate over all times
        ro, io = q[o][ind]
        Hns.append( -(2./3)*k*(ro*ro*ro - 3*ro*io*io)*Eo )

    elif (o == i):
      for ind in range(num_pts):
        ro, io = q[o][ind]
        rj, ij = q[j][ind]
        Hns.append( -2*k*(ro*ro*rj - 2*ro*io*ij - rj*io*io)*Eo ) # combinatorics factor of 3

    elif (o == j):
      for ind in range(num_pts):
        ro, io = q[o][ind]
        ri, ii = q[i][ind]
        Hns.append( -2*k*(ro*ro*ri - 2*ro*io*ii - ri*io*io)*Eo )

    elif (i == j):
      for ind in range(num_pts):
        ro, io = q[o][ind]
        rj, ij = q[j][ind]
        Hns.append( -2*k*(ro*rj*rj - 2*rj*ij*io - ro*ij*ij)*Eo )

    else:
      for ind in range(num_pts):
        ro, io = q[o][ind]
        ri, ii = q[i][ind]
        rj, ij = q[j][ind]
        Hns.append( -4*k*(ro*ri*rj - ro*ii*ij - io*ri*ij - io*ii*rj)*Eo ) # combinatorics factor of 6

    Hns_coup[(o,i,j,k)] = Hns      
      
  return Hns_coup

#########################
def Hns_coup_x(t_P, x, system, coup=False, Eo=1.0):
  """
  equivalent of Hns_coup_q but with x
  """
  network = system.network
  if not coup:
    coup = []
    for c in network.gens()[-1]:
      coup += c

  ts = np.array(t_P)*system.Porb
  Hns_coup = {}
  for o,i,j,k in coup: # iterate over all couplings
    Hns = []
    
    if (o == i) and (o == j):
      W = 3*network.wyU[o][0]
      for ind, t in enumerate(ts): # iterate over all times
        ro, io = x[o][ind]
        Hns.append( -(2./3)*k*(np.cos(W*t)*(ro*ro*ro - 3*ro*io*io) + np.sin(W*t)*(3*ro*io*io - io*io*io) )*Eo )

    elif (o == i):
      W = 2*network.wyU[o][0] + network.wyU[j][0]
      for ind, t in enumerate(ts):
        ro, io = x[o][ind]
        rj, ij = x[j][ind]
        Hns.append( -2*k*(np.cos(W*t)*(ro*ro*rj - 2*ro*io*ij - rj*io*io) + np.sin(W*t)*(ro*ro*ij  + 2*ro*io*rj - ro*ro*rj) )*Eo ) # combinatorics factor of 3

    elif (o == j):
      W = 2*network.wyU[o][0] + network.wyU[i][0]
      for ind, t in enumerate(ts):
        ro, io = x[o][ind]
        ri, ii = x[i][ind]
        Hns.append( -2*k*(np.cos(W*t)*(ro*ro*ri - 2*ro*io*ii - ri*io*io) + np.sin(W*t)*(2*ro*ri*io + ro*io*ro - ro*ri*ro) )*Eo )

    elif (i == j):
      W = network.wyU[o][0] + 2*network.wyU[i][0]
      for ind, t in enumerate(ts):
        ro, io = x[o][ind]
        rj, ij = x[j][ind]
        Hns.append( -2*k*(np.cos(W*t)*(ro*rj*rj - 2*rj*ij*io - ro*ij*ij) + np.sin(W*t)*(2*ro*rj*ij + io*rj*rj - ro*ij*ij))*Eo )

    else:
      W = network.wyU[o][0] + network.wyU[i][0] + network.wyU[j][0]
      for ind, t in enumerate(ts):
        ro, io = x[o][ind]
        ri, ii = x[i][ind]
        rj, ij = x[j][ind]
        Hns.append( -4*k*(np.cos(W*t)*(ro*ri*rj - ro*ii*ij - io*ri*ij - io*ii*rj) + np.sin(W*t)*(ro*ri*ij + ro*ii*rj + io*ri*rj - io*ii*ij) )*Eo ) # combinatorics factor of 6

    Hns_coup[(o,i,j,k)] = Hns

  return Hns_coup

####################################################################################################
#
#
#                                 interaction Hamiltonian methods
#
#
####################################################################################################
def linear_Hint_q(t_P, q, network, Eo=1.0):
  """
  computes and returns the linear interaction hamiltonian using the provided data:

  linear_H_int = \sum_i [ A_i**2 + \sum_k U_ik*( Ri*cos(k*m*O*t) - Ii*sin(k*m*O*t) )]

                                    this sum is over tidal harmonics. For most part, k=1 is the only term
  """
  Hint = []
  for ind, t_p in enumerate(t_P):
    p = 2*np.pi*t_p

    h = 0.0
    for modeNo, mode in enumerate(network.modes):
      r, i = q[modeNo][ind]
      m = mode.m
      for U,k in mode.U:
        h -= 2*U*(r*np.cos(k*m*p) - i*np.sin(k*m*p)) # contribution from linear driving

    Hint.append( h*Eo )

  return Hint

#########################
def linear_Hint_x(t_P, x, system, Eo=1.0):
  """
  equivalent of linear_Hint_q but with x
  """
  network = system.network
  Hint = []
  for ind, t_p in enumerate(t_P):
    p = 2*np.pi*t_p
    t = t_p*system.Porb

    h = 0.0
    for modeNo, mode in enumerate(network.modes):
      r, i = x[modeNo][ind]
      m = mode.m
      w = mode.w
      for U,k in mode.U:
        h -= 2*U*(r*np.cos(k*m*p-w*t) - i*np.sin(k*m*p-w*t))

    Hint.append( h*Eo )

  return Hint

####################################################################################################
#
#
#                                     Hns_plus_Hint methods
#
#
####################################################################################################
def Hint_plus_Hns_no_NLT_q(t_P, q, network, Eo=1.0):
    """
    computes the non-linear result under the assumption that the non-linear tidal forcing cancels exactly with three mode coupling from the equilibrium tide

    this turns out to be just the stellar hamiltonian + the linear interaction terms
    """
    return np.array(linear_Hint_q(t_P, q, network, Eo=Eo)) + np.array(Hns_q(q, network, Eo=Eo))

#########################
def Hint_plus_Hns_no_NLT_x(t_P, x, system, Eo=1.0):
  """
  equivalent of Hint_plut_Hns_no_NLT_q but with x
  """
  return np.array(linear_Hint_x(t_P, x, system, Eo=Eo)) + np.array(Hns_x(t_P, x, system, Eo=Eo))

#########################
def ddt_P_Hint_plus_Hns_no_NLT_q(t_P, q, system, Eo=1.0):
  """
  computes the time derivative of (Hint+Hns) explicitly through delegation to network_flow.dqdt_no_NLT
  """
  network = system.network
  N_m = len(network)

  dHint_Hns = []
  for ind, t_p in enumerate(t_P):
    p = 2*np.pi*t_p

    # compute time derivatives
    qvec = []
    for modeNo in range(N_m):
      qvec += q[modeNo][ind]
    dqdt = nf.dqdt_no_NLT(t_p*system.Porb, qvec, system)

    # compute derivative of hamiltonian
    dh = 0.0
    for o, mode in enumerate(network.modes):
      ro, io = q[o][ind]
      dro = dqdt[2*o]
      dio = dqdt[2*o+1]
      dh += 2*(ro*dro + io*dio) # linear Hns component

      m = mode.m
      for U,k in mode.U: # linear Hint component
        cos_kmp = np.cos(k*m*p)
        sin_kmp = np.sin(k*m*p)
        dh += 2*U*( k*m*system.Oorb*(ro*sin_kmp + io*cos_kmp) - (dro*cos_kmp - dio*sin_kmp) )

      for i,j,k in network.K[o]: # non-linear Hns component
        if i == j:
          ri, ii = q[i][ind]
          dh -= 2*k*( (ri*ri - ii*ii)*dro - (ri*ii + ii*ri)*dio )
        else:
          ri, ii = q[i][ind]
          rj, ij = q[j][ind]
          dh -= 4*k*( (ri*rj - ii*ij)*dro - (ri*ij + ii*rj)*dio )

    dHint_Hns.append( Eo*dh*system.Porb )

  return dHint_Hns

#########################
def ddt_P_Hint_plus_Hns_no_NLT_x(t_P, x, system, Eo=1.0):
  """
  equivalent of ddt_P_Hint_plus_Hns_no_NLT_q but with x
  """
  network = system.network
  N_m = len(network)

  dHint_Hns = []
  for ind, t_p in enumerate(t_P):
    p = 2*np.pi*t_p
    t = t_p*system.Porb

    # compute time derivatives
    xvec = []
    for modeNo in range(N_m):
      xvec += x[modeNo][ind]
    dxdt = nf.dxdt_no_NLT(t, xvec, system)

    # compute derivative of Hamiltonian
    dh = 0.0
    for o, mode in enumerate(network.modes):
      ro, io = x[o][ind]
      dro = dxdt[2*o]
      dio = dxdt[2*o+1]
      dh += 2*(ro*dro + io*dio) # linear Hns component

      m = mode.m
      w = mode.w
      for U,k in mode.U: # linear Hint component
        cos_kmp_wt = np.cos(k*m*p-w*t)
        sin_kmp_wt = np.sin(k*m*p-w*t)
        dh += 2*U*( (k*m*system.Oorb-w)*(ro*sin_kmp_wt + io*cos_kmp_wt) - (dro*cos_kmp_wt - dio*sin_kmp_wt) )

      for i,j,k in network.K[o]: # non-linear Hns component
        if i == j:
          wi = network.wyU[i][0]
          W = (w+2*wi)
          cos_Wt = np.cos(W*t)
          sin_Wt = np.sin(W*t)
          ri, ii = x[i][ind]
          dh -= 2*k*( cos_Wt*( (ri*ri-ii*ii)*dro - (ri*ii+ii*ri)*dio ) + sin_Wt*( (ri*ii+ii*ri)*dro + (ri*ri-ii*ii)*dio ) )
          dh -= 2./3*k*( -W*sin_Wt*( ri*ri*ro - ii*ii*ro - ii*ri*io - ro*ii*ro) + W*cos_Wt*( ri*ri*io + ri*ii*ro + ii*ri*ro - ii*ii*io) )

        else:
          wi = network.wyU[i][0]
          wj = network.wyU[j][0]
          W = w+wi+wj
          cos_Wt = np.cos(W*t)
          sin_Wt = np.sin(W*t)
          ri, ii = x[i][ind]
          rj, ij = x[j][ind]
          dh -= 4*k*( cos_Wt*( (ri*rj-ii*ij)*dro - (ri*ij+ii*rj)*dio ) + sin_Wt*( (ri*ij+rj*ii)*dro + (ri*rj-ii*ij)*dio) )
          dh -= 4./3*k*( -W*sin_Wt*( ri*rj*ro - ii*ij*ro - ii*rj*io - ro*ij*ro) + W*cos_Wt*( ri*rj*io + ri*ij*ro + ii*rj*ro - ii*ij*io) )

    dHint_Hns.append( Eo*dh*system.Porb )

  return dHint_Hns

############################# other stuff that has not been/may not ever be implemented ############
'''
####################################################################################################
#
#
#                        physical constants
#
#
####################################################################################################
unit_system = nm_u.unit_system
G = nm_u.G # SI units (defined in Nmode_utils.py)
Msun = nm_u.Msun
Rsun = nm_u.Rsun
Mjup = nm_u.Mjup

def Wlm(l,m):
  return 4*np.pi/(2*l+1)*sympy.N(sympy.functions.Ylm(l,m,np.pi/2,0))

##################################################
def Ialm(nlm_a, wa, wo, l, m):
  na, la, ma = nlm_a
  if la == 2: #we have an approximate formula
    return 2.5e-3*(wa/wo)**(11/6.)
  else:
    print "Ialm unknown for l,m = %d,%d" % (l,m)
    return False

##################################################
def Jablm(nlm_a, nlm_b, l, m):
  na, la, ma = nlm_a
  nb, lb, mb = nlm_b
  print "WRITE ME"
  return False

##################################################
def Hint_lin(l, m, Mprim, Mcomp, Rprim, D, Phi, q, W_Y_U, O, n_l_m, wo):
  """ 
  computes the numerical value of the interaction Hamiltonian assuming only LINEAR contributions are important.

  Hint = - sum_{a,l,m} (G*Mprim*Mcomp*Wlm*R^l)/(D^(l+1)) * [Ialm*(q_a)_conj + (1/2)*\sum_{b} J_ablm*q_a*q_b] * e^{-i*m*Phi}
  """
  print "WRITE ME"
  return False

  __Wlm = Wlm(l,m)
  Hint_lin = 0
  for modeNo in range(len(n_l_m)):
    nlma = n_l_m[modeNo]
    W,Y,U = W_Y_U[modeNo]
    wa = W
    __Ialm = Ialm(nlma, wa, wo, l, m)
    q_conj = complex((q[modeNo][0], -q[modeNo][1]))
    Hint_lin += -(G*Mprim*Mcomp*__Wlm*R**l/D**(l+1))*__Ialm*q_conj*np.exp(-i*m*Phi)

  return Hint

##################################################
def aD():
  """
  aD = - (Mprim+Mcomp)/(Mprim*Mcomp) * (\partial Hint / \partial D)
     = - G*(Mprim+Mcomp)/R^2 * \sum_{a,l,m} (l+1)*Wlm*(R/D)^(l+2) *[[Ialm*(q_a)_conj + (1/2)*\sum_{b} J_ablm*q_a*q_b] * e^{-i*m*Phi}
  """
  print "WRITE ME"
  return False

##################################################
def aPhi():
  """
  aPhi = - (Mprim+Mcomp)/(D*Mprim*Mcomp) * (\partial Hint / \partial D)
       = - G*(Mprim+Mcomp)/R^2 * \sum_{a,l,m} i*m*Wlm*(R/D)^(l+2) *[[Ialm*(q_a)_conj + (1/2)*\sum_{b} J_ablm*q_a*q_b] * e^{-i*m*Phi}
  """
  print "WRITE ME"
  return False

##################################################
def dot_a():
  """
  dot_a = 2/(O*(1-e^2)^0.5 * [aD*e*sin(Phi) + aPhi*(1+e*cos(Phi))]
  """
  print "WRITE ME"
  return False

##################################################
def dot_e():
  """
  dot_e = (1-e^2)^0.5/(O*a) * [aD*sin(Phi) + aPhi*(cos(Phi) + (e+cos(Phi))/(1+e*cos(Phi)))]
  """
  print "WRITE ME"
  return False
'''
