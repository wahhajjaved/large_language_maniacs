#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of VilfredoReloadedCore.
#
# Copyright Â© 2009-2013 Pietro Speroni di Fenizio / Derek Paterson.
#
# VilfredoReloadedCore is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation version 3 of the License.
#
# VilfredoReloadedCore is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with VilfredoReloadedCore.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################


'''
REST API
========

'''

from flask import request,\
    url_for, jsonify, make_response, abort
from VilfredoReloadedCore import app, models, emails
from VilfredoReloadedCore.auth import login_manager, login_serializer
from VilfredoReloadedCore.database import db_session
from sqlalchemy import and_
from functools import wraps
from flask import Response
import json, os
import uuid


REST_API_VERSION = 'v2'
REST_URL = '/api'
REST_URL_PREFIX = REST_URL + '/' + REST_API_VERSION

RESULTS_PER_PAGE = 50
MAX_LEN_EMAIL = 120
MAX_LEN_USERNAME = 20
MAX_LEN_PASSWORD = 120
MIN_LEN_PASSWORD = 6
MAX_LEN_ROOM = 20
MIN_LEN_ROOM = 2
MAX_LEN_PROPOSAL_TITLE = 120
MAX_LEN_PROPOSAL_ABSTRACT = 5000
MAX_LEN_PROPOSAL_BLURB = 10000
MAX_LEN_QUESTION_TITLE = 120
MAX_LEN_QUESTION_BLURB = 10000
MAX_LEN_PROPOSAL_COMMENT = 1000
MAX_LEN_PROPOSAL_QUESTION = 1000
MAX_LEN_PROPOSAL_QUESTION_ANSWER = 1000
ENDORSEMENT_TYPES = ['endorse', 'oppose', 'confused']
COMMENT_TYPES = ['for', 'against', 'question', 'answer']
PWD_RESET_LIFETIME = 3600*24*2
EMAIL_VERIFY_LIFETIME = 3600*24*2


# &hellip; ....
# &NotGreaterLess;

DOMINATION_MAP_SYMBOLS = {-2: '&approx;', -1: '&equiv;', 0: '&hellip;', 1: '^', 2: '<', 3: '&uHar;', 4: '&lHar;', 5: '<span class="partial2full">^</span>', 6: '<span class="partial2full"><</span>'}

'''
from flask_login import LoginManager
login_manager = LoginManager()
login_manager.init_app(app)
# Login_serializer used to encryt and decrypt the cookie token for the remember
# me option of flask-login
from itsdangerous import URLSafeTimedSerializer
try:
    login_serializer = URLSafeTimedSerializer(app.config['SECRET_KEY'], app.config['SALT'])
except Exception:
    print 'Failed to create login_serializer'
'''

# For a given file, return whether it's an allowed type or not
def allowed_file(filename, permitted=None):
    permitted = permitted or app.config['ALLOWED_EXTENSIONS']
    return '.' in filename and \
           filename.rsplit('.', 1)[1] in permitted

@login_manager.token_loader
def load_token(token):
    """
    Flask-Login token_loader callback.
    The token_loader function asks this function to take the token that was
    stored on the users computer process it to check if its valid and then
    return a User Object if its valid or None if its not valid.
    """

    app.logger.debug("load_token called...")

    #The Token itself was generated by User.get_auth_token.  So it is up to
    #us to known the format of the token data itself.

    #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which
    #allows us to have a max_age on the token itself.  When the cookie is stored
    #on the users computer it also has a exipry date, but could be changed by
    #the user, so this feature allows us to enforce the exipry date of the token
    #server side and not rely on the users cookie to exipre.
    max_age = app.config["REMEMBER_COOKIE_DURATION"].total_seconds()

    #Decrypt the Security Token, data = [username, hashpass]
    #from . import login_serializer

    try:
        data = login_serializer.loads(token, max_age=max_age)
    except:
        app.logger.debug('load_token raised error')
        return None

    #Find the User
    user = models.User.get(int(data[0]))

    #Check Password and return user or None
    if user and data[1] == user.password:
        return user
    return None

def authenticate():
    """Sends a 403 response that enables basic auth"""
    return Response(
        'You have to login to make this request', 403,
        {'WWW-Authenticate': 'Basic realm="Login Required"'})

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        # app.logger.debug("request.authorization========>>>>: %s", request.authorization)
        auth = request.authorization
        if not auth:
            return jsonify(message='auth not defined'), 403
        if auth.username == '':
            return jsonify(message='no username received'), 403
        if auth.password == '':
            # app.logger.debug('requires_auth: Token set')
            token_valid = load_token(auth.username)
            if token_valid:
                # app.logger.debug('requires_auth: Token is valid')
                return f(*args, **kwargs)
            else:
                # app.logger.debug('requires_auth: Token is not valid')
                # return authenticate()
                return jsonify(message='no password received, incorrect token supplied'), 403
        elif check_auth(auth.username, auth.password):
            # app.logger.debug('requires_auth: username and password valid')
            return f(*args, **kwargs)
        else:
            # app.logger.debug('requires_auth: username and password not valid')
            # return authenticate()
            return jsonify(message='username and password not valid'), 403
    return decorated

def check_auth(username, password):
    '''
    .. function:: check_auth(username, password)

    Authenticates user.

    :param username: user name.
    :type username: String
    :param password: user name.
    :type password: String
    :rtype: Boolean
    '''
    user = None
    if username == '' or password == '':
        return False
    try:
        user = models.User.query.filter_by(username=username).one()
    except:
        pass
    if user is None:
        return False
    else:
        return user.check_password(password)

def get_authenticated_user(request):
    '''
    .. function:: get_authenticated_user(request)

    Returns the authenticated user.

    :param request: HTTP request.
    :type request: Object
    :rtype: User or None
    '''
    if request.authorization:
        if request.authorization.password == '':
            user = load_token(request.authorization.username)
            return user
        elif check_auth(request.authorization.username, request.authorization.password):
            user = models.User.query.\
                filter_by(username=request.authorization.username).one()
            return user
        else:
            return None
    else:
        app.logger.debug("get_authenticated_user: no authorization sent")
        return None


@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'Not found'}), 404)


@app.errorhandler(400)
def bad_request(error):
    return make_response(jsonify({'error': 'Bad request'}), 400)


#
# Index
#
@app.route(REST_URL, methods=['GET'])
@app.route(REST_URL + '/', methods=['GET'])
@app.route(REST_URL + '/index', methods=['GET'])
def api_index():
    '''
    .. http:get:: /

        An authentication token.

        **Example request**:

        .. sourcecode:: http

            GET / HTTP/1.1
            Host: vilfredo.org
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "current_api_url": "https://" + app.config['SITE_DOMAIN'] + "/api/v1",
                "api_v1_url": "https://" + app.config['SITE_DOMAIN'] + "/api/v1"
            }

        :statuscode 200: no error
    '''
    app.logger.debug("api_index called...\n")
    '''
    api_info = {
        "current_api_url": "https://api.vilrefo.org/v1",
        "api_v1_url": "https://api.vilrefo.org/v1"
    }
    '''

    api_info = {
        "current_api_url": "https://" + app.config['SITE_DOMAIN'] + "/api/v1",
        "api_v1_url": "https://" + app.config['SITE_DOMAIN'] + "/api/v1"
    }
    return jsonify(api_info), 200


#
# Get Auth Token
#
@app.route(REST_URL_PREFIX + '/authtoken', methods=['POST'])
@requires_auth
def api_get_auth_token():
    '''
    .. http:get:: /authtoken/

        An authentication token.

        **Example request**:

        .. sourcecode:: http

            GET /authtoken HTTP/1.1
            Host: vilfredo.org
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
               "token": "fr56gy6fuj78hg6549judhyey"
            }

        :statuscode 200: no error
        :statuscode 400: there's no user
    '''
    app.logger.debug("api_get_auth_token called...\n")
    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not found"), 400

    # Check if user needs to verify his email address
    verify_email = models.VerifyEmail.query.filter_by(user_id=user.id).first()
    if verify_email:
        return jsonify(message = "User email unverified.",
                       user_message = "Before you can log in you must activate your account by clicking on the link we emailed to you when you registered."), 400

    token = user.get_auth_token()
    response = {'token': token}

    if request.json and 'eit' in request.json:
        app.logger.debug('Email Invite Token found...')
        email_invite_token = request.json['eit']
        question_id = models.EmailInvite.accept(user, email_invite_token)
        # Check if token OK
        if question_id:
            response['question_url'] = url_for('display_question', question_id=question_id)
            app.logger.debug('User accepted invite to question %s...', question_id)
        else:
            app.logger.debug('User accept invite to question %s failed for some reason...', question_id)

    return jsonify(response), 200

#
# Get Current User details
#
@app.route(REST_URL_PREFIX + '/currentuser', methods=['GET'])
@requires_auth
def api_get_current_user():
    '''
    .. http:get:: /currentuser

        Get the current user.

        **Example request**:

        .. sourcecode:: http

            GET /users/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "user": 
                {   "username": "john", 
                    "url": "/api/v1/users/1", 
                    "registered": "2015-01-17 23:06:08", 
                    "id": "1", 
                    "email": "john@example.com", 
                    "last_seen": "2015-01-17 23:06:08"
                }
            }

        :param user_id: user id
        :type user_id: int
        :statuscode 200: no error
        :statuscode 401: there's no user
    '''
    app.logger.debug("api_get_current_user called...\n")
    user = get_authenticated_user(request)
    if not user:
        app.logger.debug("user not found...\n")
        abort(401)
    userdata = user.get_public()
    userdata['email'] = user.email
    return jsonify(user=userdata), 200


#
# Get Users
#
@app.route(REST_URL_PREFIX + '/users', methods=['GET'])
@app.route(REST_URL_PREFIX + '/users/<int:user_id>', methods=['GET'])
def api_get_users(user_id=None):
    '''
    .. http:get:: /users/(int:user_id)

        A user or list of users.

        **Example request**:

        .. sourcecode:: http

            GET /users/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
               "total_items": 5,
               "items": "2",
               "objects":
               [
                   {
                       "username": "john",
                       "url": "/users/1",
                       "registered": "2013-08-12 09:51:38.559222",
                       "id": "1",
                       "last_seen": "2013-08-12 09:51:38.559240"
                   },
                   {
                       "username": "susan",
                       "url": "/users/2",
                       "registered": "2013-08-12 09:51:38.576731",
                       "id": "2",
                       "last_seen": "2013-08-12 09:51:38.576745"
                   }
               ],
               "page": "1",
               "pages": "2"
            }

        :param user_id: user id
        :type user_id: int
        :query page: page number. default is 1
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_users called...\n")

    # Get authenticated user or None
    current_user = get_authenticated_user(request)

    if user_id is not None:
        user = models.User.query.get(int(user_id))
        if user is None:
            abort(404)

        results = user.get_public()

        if current_user and current_user.id == user.id:
            results['email'] = user.email

        return jsonify(user=results), 200

    else:
        page = int(request.args.get('page', 1))
        users = models.User.query.paginate(page,
                                           RESULTS_PER_PAGE,
                                           False)
        items = len(users.items)
        pages = users.pages
        total_items = users.total

        results = []
        for u in users.items:
            results.append(u.get_public())

        return jsonify(total_items=total_items, items=str(items),
                       page=str(page), pages=str(pages),
                       users=results), 200


# Update User Details
@app.route(REST_URL_PREFIX + '/users/<int:user_id>', methods=['PATCH'])
@requires_auth
def api_update_user(user_id):
    '''
    .. http:patch:: /users/(int:user_id)

        Update a user's details'.

        **Example request**:

        .. sourcecode:: http

            PATCH /users/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "url": "/users/1"
            }

        :param user_id: user id
        :type user_id: int
        :json new_username: new username
        :json new_password: new password
        :json new_email: new email address
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    if user_id is None:
        abort(404)

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("api_update_user called by %s...\n", user.id)

    if int(user_id) != user.id:
        response = {'message': 'You are not authorized to edit this resource'}
        return jsonify(objects=response), 401

    if not request.json:
        app.logger.debug("Non json request received...\n")
        abort(400)

    elif 'new_username' in request.json and \
            (request.json['new_username'] == '' or
             len(request.json['new_username']) > MAX_LEN_USERNAME):
        app.logger.debug("1...\n")
        abort(400)

    elif 'new_email' in request.json and \
            (request.json['new_email'] == '' or
             request.json['new_email'] > MAX_LEN_EMAIL):
        app.logger.debug("2...\n")
        abort(400)

    elif 'new_password' in request.json and \
            (len(request.json['new_password']) < MIN_LEN_PASSWORD or
             len(request.json['new_password']) > MAX_LEN_PASSWORD):
        app.logger.debug("3...\n")
        abort(400)

    elif models.User.username_available(request.json['new_username'])\
            is not True:
        message = "Username not available"
        # return jsonify(message=message), 400
        return jsonify(message = "Username not available"), 400

    elif models.User.email_available(request.json['email']) is not True:
            response = {'message': 'Someone has already registered with that email.'}
            return jsonify(objects=response), 400

    user.username = request.json.get('new_username', user.username)
    user.email = request.json.get('new_email', user.email)

    if 'new_password' in request.json:
        user.set_password(request.json['new_password'])

    db_session.add(user)
    db_session.commit()
    response = {'url': url_for('api_get_users', user_id=user.id)}

    return jsonify(object=response), 201


#
# Upload avatar
#
@app.route(REST_URL_PREFIX + '/upload_avatar', methods=['POST'])
@requires_auth
def api_upload_avatar():
    '''
    .. http:post:: /upload_avatar

        Request password reset.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "message": "File saved",
                "url": "http://0.0.0.0:8080/static/usercontent/profiles/1/831e44b41f77c66d6f97aa8ee4977275.jpg"
            }

        :json email: registered email address
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: bad request
    '''
    app.logger.debug("api_upload_avatar called.....\n")
    
    # Must be authenticated
    user = get_authenticated_user(request)
    if not user:
        app.logger.debug("api_upload_avatar: user not logged in.....\n")
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    # avatars = UploadSet('avatars', IMAGES)

    app.logger.info("requst data %s", request.files)
    app.logger.info("requst data %s", request.files['avatar'])
    avatar = request.files['avatar']
    app.logger.info("avatar file = %s", avatar)
    app.logger.info("avatar filename = %s", avatar.filename)
    if not avatar:
        message = 'Failed to upload file'
        return jsonify(message=message, error=message), 401
    
    if not allowed_file(avatar.filename):
        message = 'Avatar file must be of type: ' + ', '.join(app.config['ALLOWED_EXTENSIONS'])
        return jsonify(message=message, error=message), 401

    avatar_saved = user.set_avatar(avatar)

    if avatar_saved == False:
        message = 'Failed to save file'
        return jsonify(message=message, error=message), 401

    message = 'Avatar saved'
    return jsonify(message=message,
                   url=app.config['PROTOCOL'] + app.config['SITE_DOMAIN'] + '/' + avatar_saved), 201


#
# Password reset request
#
@app.route(REST_URL_PREFIX + '/request_password_reset', methods=['POST'])
def api_request_password_reset():
    '''
    .. http:post:: /request_password_reset

        Request password reset.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "message": "Password reset email sent"
            }

        :json email: registered email address
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_request_password_reset called.....\n")

    if not request.json:
        app.logger.debug("Non json request received...\n")
        message = "Non json request received"
        return jsonify(message=message), 401

    elif not 'email' in request.json or request.json['email'] == '' \
            or len(request.json['email']) > MAX_LEN_EMAIL:
        message = "A valid email is required"
        return jsonify(message=message), 402

    email = request.json['email']
    app.logger.debug("Reset Email given = %s\n", email)
    user = models.User.query.filter_by(email=email).first()
    app.logger.debug("DB OK")
    if not user:
        message = "That is not a registered email address."
        return jsonify(message=message), 403

    pwd_reset = db_session.query(models.PWDReset)\
            .filter(models.PWDReset.email == email)\
            .first()
    if pwd_reset:
        message = "A password had already been requested for this address. Please check your spam folder."
        return jsonify(message=message), 403

    pwd_reset_token = uuid.uuid4().get_hex()
    timeout = models.get_timestamp() + PWD_RESET_LIFETIME
    pwd_reset = models.PWDReset(user, pwd_reset_token, timeout)
    db_session.add(pwd_reset)
    db_session.commit()
    # email reset token to user
    ret_code = emails.send_password_reset_email(email, pwd_reset_token)
    app.logger.debug("api_request_password_reset: Ret Code from send_password_reset_email = %s", ret_code)
    message = 'Password reset email sent'
    return jsonify(message=message), 201


#
# Set new password and generate new authentication token
#
@app.route(REST_URL_PREFIX + '/reset_password', methods=['POST'])
def api_reset_password():
    '''
    .. http:post:: /reset_password

        Request password reset.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "message": "Password reset",
                "token": "gd6ghgjh7d6hehftt76gTR5677eh"
            }

        :json password: new password
        :json password2: new password confirmation
        :json token: password reset token
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_reset_password called...\n")

    if not 'token' in request.json or request.json['token'] == '':
        message = 'You must pass a password reset token'
        return jsonify(message=message), 402
    reset_token = request.json['token']

    if not 'password' in request.json or not 'password2' in request.json or \
            request.json['password'] != request.json['password2'] or \
            request.json['password'] == '' or \
            len(request.json['password']) < MIN_LEN_PASSWORD or \
            len(request.json['password']) > MAX_LEN_PASSWORD:
        message = "Passwords %s must match and must be between %s and %s characters" %\
            (request.json['password'], MIN_LEN_PASSWORD, MAX_LEN_PASSWORD)
        return jsonify(message=message), 400

    pwd_reset = db_session.query(models.PWDReset)\
            .filter(models.PWDReset.token == reset_token)\
            .first()

    if not pwd_reset:
        response = {"message": "Invalid password reset token"}
        return jsonify(response), 400

    user = models.User.query.get(pwd_reset.user_id)
    if not user:
        response = {"message": "User not found"}
        return jsonify(response), 400

    app.logger.debug("User from token = %s\n", user.id)

    # Delete reset token entry
    db_session.delete(pwd_reset)

    # Set new password
    new_password = request.json['password']
    user.set_password(new_password)
    db_session.add(user)
    db_session.commit()

    # Generate new auth token
    authtoken = user.get_auth_token()
    app.logger.debug("New auth token generated")

    message = 'Password reset'
    return jsonify(message=message, token=authtoken), 201


#
# Create User
#
@app.route(REST_URL_PREFIX + '/users', methods=['POST'])
def api_create_user():
    '''
    .. http:post:: /users

        Create a new user.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/users/1",
                "email_sent": true
            }

        :json username: username
        :json email: email address
        :json password: password
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_user called...\n")

    app.logger.debug("Request %s...\n", request.json)

    if not request.json:
        app.logger.debug("Non json request received...\n")
        message = "Non json request received"
        return jsonify(message=message), 400

    elif not 'username' in request.json or request.json['username'] == '' \
            or len(request.json['username']) > MAX_LEN_USERNAME:
        message = "Username must be less than %s characters" % MAX_LEN_USERNAME
        return jsonify(message=message), 400

    elif not 'email' in request.json or request.json['email'] == '' \
            or len(request.json['email']) > MAX_LEN_EMAIL:
        message = "Email required and must be shorter than %s characters" %\
                  MAX_LEN_EMAIL
        return jsonify(message=message), 400

    elif not 'password' in request.json or request.json['password'] == '' or \
            len(request.json['password']) < MIN_LEN_PASSWORD or \
            len(request.json['password']) > MAX_LEN_PASSWORD:
        message = "Password must be between %s and %s characters" %\
            (MIN_LEN_PASSWORD, MAX_LEN_PASSWORD)
        return jsonify(message=message), 400

    elif models.User.username_available(request.json['username'])\
            is not True:
        message = "Username not available"
        return jsonify(message=message), 400
        # return jsonify(message = "Username not available"), 400
        # return make_response(jsonify({'error': 'Username not available'}), 400) winter

    elif models.User.email_available(request.json['email']) is not True:
        message = "Someone has already registered with that email."
        return jsonify(message=message), 400

    user = models.User(request.json['username'],
                       request.json['email'],
                       request.json['password'])
    db_session.add(user)
    db_session.commit()

    verify_new_users_email_adress = True
    response = {}
    email_sent = False

    if 'eit' in request.json:
        app.logger.debug('Email Invite Token found: %s', request.json['eit'])
        email_invite_token = request.json['eit']
        question_id = models.EmailInvite.accept(user, email_invite_token)
        # Check if token OK
        if question_id:
            app.logger.debug('User %s accepted invite to question %s...', user.username, question_id)
            # No need to verify email address
            verify_new_users_email_adress = False
            # Create auth token to log the user in
            auth_token = user.get_auth_token()

            # Check if question still exists - eg hasn't been deleted
            question = models.Question.query.get(question_id)
            if question:
                app.logger.debug('Quetion Found: send %s a welcome_to_question_email to %s...', user.username, user.email)
                emails.send_welcome_to_question_email(user, question)
            else:
                app.logger.debug('Quetion Not Found: send %s a welcome_to_notfound_question_email to %s...', user.username, user.email)
                emails.send_welcome_to_notfound_question_email(user, question_id)

            response = {'url': url_for('api_get_users', user_id=user.id), 
                        'token': auth_token, 'activation_email_sent': False}

            # send question link only if question acually exists
            if question:
                response['question_url'] = url_for('display_question', question_id=question_id)

    else:
        response = {'url': url_for('api_get_users', user_id=user.id), 'activation_email_sent': False}
    
    # Send verification email unless deactivate
    if verify_new_users_email_adress and os.environ.get('EMAIL_VALIDATION_OFF', '0') == '0':
        email = request.json['email']
        token = uuid.uuid4().get_hex()
        timeout = models.get_timestamp() + EMAIL_VERIFY_LIFETIME
        verify_email = models.VerifyEmail(user, email, token, timeout)
        ret_code = emails.send_email_verification(user.id, email, token)
        app.logger.debug("api_create_user: Ret Code from send_email_verification = %s", ret_code)
        verify_email.email_sent = 1
        db_session.add(verify_email)
        db_session.commit()
        response['activation_email_sent'] = True

    return jsonify(response), 201



#
# Get Questions
#
@app.route(REST_URL_PREFIX + '/questions', methods=['GET'])
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>', methods=['GET'])
@requires_auth # added
def api_get_questions(question_id=None):
    '''
    .. http:get:: /questions/(int:question_id)

        A question or list of questions.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "total_items": "3",
              "items": "2",
              "objects": [
                {
                  "last_move_on": "2013-08-12 09:51:38.632780",
                  "created": "2013-08-12 09:51:38.632763",
                  "title": "My question",
                  "minimum_time": "0",
                  "maximum_time": "604800",
                  "id": 1,
                  "blurb": "My blurb"
                },
                {
                  "last_move_on": "2013-08-12 09:51:38.665584",
                  "created": "2013-08-12 09:51:38.665570",
                  "title": "Too Many Chefs",
                  "minimum_time": "0",
                  "maximum_time": "604800",
                  "id": 3,
                  "blurb": "How can they avoid spoiling the broth?"
                }
              ],
              "page": "1",
              "pages": "1"
            }

        :param question_id: question id
        :type question_id: int
        :param room: room title
        :type room: string
        :query page: page number. default is 1
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_questions called...\n")

    # shark
    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    if question_id is not None:

        question = models.Question.query.get(question_id)
        if question is None:
            return jsonify(message = "Question not found"), 404

        # Check user permission
        perm = question.get_permissions(user)
        if not perm:
            app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
            return jsonify(message = "Question not found"), 404

        question_data = question.get_public(user)
        app.logger.debug("Qustion data ==> %s", question_data);

        # Test for jsonp request
        if False or 'callback' in request.args:
            d = json.dumps(dict(question=question_data))
            return request.args['callback'] + '(' + d + ');', 200
        else:
            return jsonify(question=question_data), 200

    else:
        questions = user.get_active_questions()
        items = len(questions)

        results = []
        for q in questions:
            results.append(q.get_public())

        # Test for jsonp request
        if False or 'callback' in request.args:
            d = json.dumps(dict(items=str(items),
                           questions=results))
            return request.args['callback'] + '(' + d + ');', 200

        else:
            return jsonify(items=str(items),
                           questions=results), 200

#
# Create Question
#
@app.route(REST_URL_PREFIX + '/questions', methods=['POST'])
@requires_auth
def api_create_question():
    '''
    .. http:post:: /questions

        Create a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/questions/1"
            }

        :json title: question title
        :json blurb: question content
        :json room: question room
        :json minimum_time: minimum time before question can be moved on
        :json maximum_time: maximum time before question is automatically moved on
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_question called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    app.logger.debug("Authenticated User = %s\n", user.id)

    if not request.json:
        app.logger.debug("Non json request received...\n")
        response = {message: "No question data received"}
        return jsonify(response), 400

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_QUESTION_TITLE:
        response = {message: "Question title must not be empty and no longer than " + str(MAX_LEN_QUESTION_BLURB) + " characters"}
        return jsonify(response), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_QUESTION_BLURB:
        # abort(400)
        response = {message: "Question text must not be empty and no longer than " + str(MAX_LEN_QUESTION_BLURB) + " characters"}
        return jsonify(response), 400

    elif 'room' in request.json and request.json['room'] != ''\
         and (len(request.json['room']) > MAX_LEN_ROOM
              or len(request.json['room']) < MIN_LEN_ROOM):
        return jsonify(message="Room name must longer than " + str(MIN_LEN_ROOM) + " and less than " + str(MAX_LEN_ROOM) + " characters"), 400

    # Set required parameters
    title = request.json.get('title')
    blurb = request.json.get('blurb')
    # Set optional parameters
    room = request.json.get('room', None)
    minimum_time = request.json.get('minimum_time', 0)
    maximum_time = request.json.get('maximum_time', 2592000)

    question = models.Question(user,
                               title,
                               blurb,
                               minimum_time,
                               maximum_time,
                               room)
    db_session.add(question)
    db_session.commit()

    # Set default threshold for voting map
    question.thresholds.append(models.Threshold(question))
    user.invites.append(models.Invite(user, user.id, models.Question.VOTE_PROPOSE_READ, question.id))
    db_session.commit()

    # url = {'url': url_for('api_get_questions', question_id=question.id)}
    # return jsonify(url), 201

    return jsonify(question=question.get_public()), 201


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/subscribers', methods=['GET'])
@requires_auth # added
def api_question_subscribers(question_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/subscribers

        A list of question subscribers.

        **Example request**:

        .. sourcecode:: http

            GET questions/3/subscribers HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "objects": [
                {
                  "url": "/users/1/subscriptions/3",
                  "how": "weekly",
                  "last_update": "None",
                  "question_id": "3"
                },
                {
                  "url": "/users/5/subscriptions/3",
                  "how": "daily",
                  "last_update": "None",
                  "question_id": "3"
                }
              ],
              "num_items": "2",
              "items": 2,
              "question_id": "3",
              "page": "1",
              "pages": "1"
            }

        :param question_id: question id
        :type question_id: int
        :query page: page number, default is 1
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_subscribers called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    page = int(request.args.get('page', 1))
    # subscribers = question.subscriber_update.\
        # paginate(page, RESULTS_PER_PAGE, False)
    subscribers = models.Update.query.filter_by(question_id=question.id).\
        paginate(page, RESULTS_PER_PAGE, False)

    items = len(subscribers.items)
    pages = subscribers.pages

    results = []
    for s in subscribers.items:
        results.append(s.get_public())

    return jsonify(question_id=str(question.id),
                   items=(items), page=str(page), pages=str(pages),
                   num_items=str(subscribers.total), objects=results), 200

# Get proposals (Fetch Proposals)
#
# Add options to return only pareto, inherited or new user proposals
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals', methods=['GET'])
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['GET'])
@requires_auth # added
def api_get_question_proposals(question_id=None, proposal_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)

        A proposal or list of proposals.

        **Example request**:

        .. sourcecode:: http

            GET /questions/22/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "total_items": "4",
                "items": "2",
                "proposals": [
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills First Proposal",
                  "url": "/api/v1/questions/1/proposals/1",
                  "abstract": null,
                  "created": "2013-08-15 18:32:00.154844",
                  "id": "1",
                  "blurb": "Bills blurb of varying interest",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills Second Proposal",
                  "url": "/api/v1/questions/1/proposals/2",
                  "abstract": "This is too abstract for an abstract",
                  "created": "2013-08-15 18:32:00.176816",
                  "id": "2",
                  "blurb": "Bills blurb of varying disinterest",
                  "generation_created": "1"
                }
                ],
                "page": "1",
                "pages": "2"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :query generation: question generation, default is current
        :query page: page number, default is 1
        :query user_only: boolean, default false
        :query inherited_only: boolean, default is false
        :statuscode 200: no error
        :statuscode 404: there's no proposal
    '''
    app.logger.debug("api_get_question_proposals called...\n")

    # See if user logged in
    app.logger.debug("Request: %s", request)
    if request.authorization:
        app.logger.debug("Request Authorization IS SET: %s", request.authorization)
    else:
        app.logger.debug("Request Authorization NOT SET")

    # if 'request.json' in locals() or 'request.json' in globals():
    #    app.logger.debug("BOOM!!!")

    user = get_authenticated_user(request)
    app.logger.debug("Got user...")
    if user:
        app.logger.debug("User logged in %s", user.username)
    else:
        app.logger.debug("User not logged in")
    # user = None

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        return jsonify(message="question_id not set"), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify(message="Question not found"), 404

    if not proposal_id is None:
        proposal_id = int(proposal_id)
        proposal = question.proposals.filter_by(id=proposal_id).one()
        if proposal is None:
            return jsonify(message="Proposal not found"), 404

        result = proposal.get_public()

        # Test for jsonp request
        if False or 'callback' in request.args:
            d = json.dumps(dict(proposal=result))
            return request.args['callback'] + '(' + d + ');', 200
        else:
            return jsonify(proposal=result), 200

    else:
        generation = int(request.args.get('generation', question.generation))
        page = int(request.args.get('page', 1))

        # proposals = models.Proposal.query.join(models.QuestionHistory).\
        #    filter(models.QuestionHistory.question_id == question.id).\
        #    filter(models.QuestionHistory.generation == generation).\
        #    paginate(page, RESULTS_PER_PAGE, False)

        user_only = request.args.get('user_only', False)
        # Return empty list if user_only requested and user not authenticated
        if user_only and not user:
            app.logger.debug("api_get_question_proposals: user_only True but no current user, return empty list")
            return jsonify(total_items=str(0), items=str(0),
                          page=str(1), pages=str(1),
                          proposals=[]), 200

        inherited_only = request.args.get('inherited_only', False)
        # Return empty list if inherited_only requested and in first generation
        if inherited_only and question.generation == 1:
            return jsonify(total_items=str(0), items=str(0),
                          page=str(1), pages=str(1),
                          proposals=[]), 200

        query = models.Proposal.query.join(models.QuestionHistory).\
            filter(models.QuestionHistory.question_id == question.id).\
            filter(models.QuestionHistory.generation == generation)

        if user and user_only:
            app.logger.debug("api_get_question_proposals: user_only True, add user filter")
            query = query.filter(models.Proposal.user_id == user.id)

        elif inherited_only:
            query = query.filter(models.Proposal.generation_created < question.generation)

        proposals = query.paginate(page, RESULTS_PER_PAGE, False) # final winners

        items = len(proposals.items)
        pages = proposals.pages
        total_items = proposals.total

        results = []
        for p in proposals.items:
            results.append(p.get_public(user))

        # Test for jsonp request
        if False or 'callback' in request.args:
            d = json.dumps(dict(total_items=str(total_items), items=str(items),
                           page=str(page), pages=str(pages),
                           proposals=results))
            return request.args['callback'] + '(' + d + ');', 200
        else:
            # Return json
            return jsonify(total_items=str(total_items), items=str(items),
                          page=str(page), pages=str(pages),
                          proposals=results), 200


# Support Comment
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>/support',
    methods=['POST'])
@requires_auth
def api_support_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)/support

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/comments/77/support HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                 "message": "Support Added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_support_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify(message = "URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify(message = "Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify(message = "Comment not found"), 404

    # Support comment
    user.support_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Return updated supporters list
    supporters = comment.fetch_supporter_ids()
    return jsonify(message="Support added",
                   supporters=str(supporters)), 201


# Unsupport Comment
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>/support',
    methods=['DELETE'])
@requires_auth
def api_unsupport_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:delete:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)/support

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/45/proposals/47/comments/77/support HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Support Removed"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_unsupport_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify(message = "URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify(message = "Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify(message = "Comment not found"), 404

    # Support comment
    user.unsupport_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Return updated supporters list
    supporters = comment.fetch_supporter_ids()
    app.logger.debug("Updated supporters list==> %s", supporters)
    return jsonify(message="Support removed",
                   supporters=str(supporters)), 201


#
# Get Comments
#
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments',
    methods=['GET'])
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['GET'])
@requires_auth # added
def api_get_proposal_comments(question_id, proposal_id, comment_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)

        A user or list of comments.

        **Example request**:

        .. sourcecode:: http

            GET /questions/45/proposals/47/comments HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
               "total_items": 2,
                "items": "2",
                "comments": [
                    {
                      "comment": "This is terrible!",
                      "generation": "1",
                      "question_url": "/api/v1/questions/1",
                      "author_url": "/api/v1/users/1",
                      "comment_type": "oppose",
                      "created": "2013-10-21 15:43:17.558333",
                      "url": "/api/v1/questions/1/proposals/4/comments/1",
                      "proposal_url": "/api/v1/questions/1/proposals/4",
                      "id": "1"
                    },
                    {
                      "comment": "I feel very confused!",
                      "generation": "1",
                      "question_url": "/api/v1/questions/1",
                      "author_url": "/api/v1/users/3",
                      "comment_type": "confused",
                      "created": "2013-10-21 15:43:17.695875",
                      "url": "/api/v1/questions/1/proposals/4/comments/2",
                      "proposal_url": "/api/v1/questions/1/proposals/4",
                      "id": "2"
                    }
                ]
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :param comment_id: comment id
        :type comment_id: int or None
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_comments called...\n")

    # Get authenticated user or None
    user = get_authenticated_user(request)
    #if not user:
    #    abort(401)

    if question_id is None or proposal_id is None:
        message = {"message": "Question or proposal ids not set"}
        return jsonify(message), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        message = {"message": "Question not found"}
        return jsonify(message), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        message = {"message": "Proposal not found"}
        return jsonify(message), 404

    if comment_id is not None:
        comment = models.Comment.query.get(int(comment_id))
        if comment is None:
            message = {"message": "Comment not found"}
            return jsonify(message), 404

        result = comment.get_public()

        return jsonify(comment=result), 200

    else:
        generation = None
        if generation in request.args:
            generation = int(request.args['generation'])

        app.logger.debug("Get Comments: generation = %s", generation)

        comments = proposal.get_comments(generation)

        items = len(comments)
        total_items = len(comments)

        results = []
        for c in comments:
            results.append(c.get_public())

        return jsonify(total_items=total_items, items=str(items),
                       comments=results), 200


# Update comment if no other support
#
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['PATCH'])
@requires_auth
def api_update_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:patch:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            PATCH /questions/45/proposals/47/comments/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Comment Updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :json comment_type: one of endorse, oppose or confused
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify(message = "Comment not found"), 400

    # Only the author can edit a comment
    if comment.user_id != user.id:
        return jsonify(message = "Only the author can edit a comment"), 403

    # Make sure there are no other supportes (other than author)
    supporters = comment.supporters.all()
    if len(supporters) != 1 and supporters[0] != user:
        return jsonify(message = "Comment supported by other users cannot be edited."), 403

    app.logger.debug("request.json = %s\n", request.json)

    if not 'comment_type' in request.json or not request.json['comment_type'] in COMMENT_TYPES:
        message = {"message": "comment_type must be one of endorse, oppose or confused"}
        return jsonify(message), 400

    comment_type = request.json['comment_type']

    new_comment_text = None
    if 'new_comment_text' in request.json:
        if request.json['new_comment_text'] == '' \
                or len(request.json['new_comment_text']) > MAX_LEN_PROPOSAL_COMMENT:
            message = {"message": "Comment text must be no longer than " + str(MAX_LEN_PROPOSAL_COMMENT) + " characters"}
            return jsonify(message), 400
        else:
            new_comment_text = request.json['new_comment_text']

    app.logger.debug("comment_type = %s\n", comment_type)
    app.logger.debug("new_comment_text = %s\n", new_comment_text)

    # Check if update details are identical to existing details
    if comment_type == comment.comment_type and comment.comment == new_comment_text:
        return jsonify(message = "Update matches original"), 409

    # Check if duplcate comment already exists
    existing_comment = models.Comment.fetch_if_exists(proposal, new_comment_text, comment_type)
    if (existing_comment and existing_comment.id != comment.id):
        return jsonify(message = "Identical comment found"), 400

    # Everything OK - update comment
    comment.comment = new_comment_text
    comment.comment_type = comment_type
    db_session.commit()
    return jsonify(message="Comment updated"), 201


# Create Comment
#
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments',
    methods=['POST'])
@requires_auth
def api_add_proposal_comment(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments

        Add a comment.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/comments HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                 "message": "Comment added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json comment_type: one of endorse, oppose or confused
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        # abort(401)
        message = {"message": "You need to be logged in to post a comment"}
        return jsonify(message), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        message = {"message": "Question not found"}
        return jsonify(message), 400

    # Consider allowing comments during writing
    elif question.phase != 'voting':
        message = {"message": "Adding comments is only allowed during the voting phase"}
        return jsonify(message), 403

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        message = {"message": "Proposal not found"}
        return jsonify(message), 400

    app.logger.debug("request.json = %s\n", request.json)

    if not 'comment_type' in request.json or not request.json['comment_type'] in COMMENT_TYPES:
            message = {"message": "comment_type must be one of for, against, question or answer"}
            return jsonify(message), 400

    comment_type = request.json['comment_type']

    comment = None
    if 'comment' in request.json:
        if request.json['comment'] == '' \
                or len(request.json['comment']) > MAX_LEN_PROPOSAL_COMMENT:
            message = {"message": "Comment text must be no longer than " + str(MAX_LEN_PROPOSAL_COMMENT) + " characters"}
            return jsonify(message), 400
        else:
            comment = request.json['comment']
    else:
        message = {"message": "No comment text passed"}
        return jsonify(message), 400

    reply_to = 0
    if 'reply_to' in request.json:
        try:
            reply_to = int(request.json['reply_to'])
        except:
            app.logger.debug('Failed to convert reply_to param to integer')
            reply_to = 0

    app.logger.debug("comment_type = %s\n", comment_type)
    app.logger.debug("comment = %s\n", comment)
    app.logger.debug("reply_to = %s\n", reply_to)

    # List of supported comments
    comment_id = None
    new_comment = None

    # Fetch the comment which matches comment text or create new one
    if (comment):
        existing_comment = models.Comment.fetch_if_exists(proposal, comment, comment_type)
        if (existing_comment):
            message = {"message": "Comment already exists for this proposal"}
            return jsonify(message), 400
        else:
            new_comment = models.Comment(user, proposal, comment, comment_type, reply_to)
            if (new_comment is False):
                return jsonify(message="Could not create comment"), 500
            else:
                db_session.add(new_comment)
                db_session.commit()
                user.support_comment(new_comment)
                db_session.commit()
                response = new_comment.get_public()
                response['question_count'] = str(proposal.get_question_count())
                response['comment_count'] = str(proposal.get_comment_count())
                return jsonify(comment=response), 201


# Delete comment (if unsupported by anyone else)
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['DELETE'])
@requires_auth
def api_delete_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:delete:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)

        Delete a comment.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/45/proposals/47/comments/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Comment deleted"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_delete_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify(message = "URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify(message = "Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify(message = "Comment not found"), 404

    if comment.supporters.count() > 1:
        return jsonify(message = "Comment has other supporters so cannot be deleted"), 404

    # Unsupport comment
    user.unsupport_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Delete comment
    proposal.comments.remove(comment)
    db_session.commit()
    return jsonify(message="Comment deleted"), 201


# Create Endorsement
#
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/endorsements',
    methods=['POST'])
@requires_auth
def api_add_proposal_endorsement(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsements

        Endorse a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/endorsements HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Endorsement added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json endorsement_type: one of endorse, oppose or confused
        :json comments: ids of supported comments
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_endorsement called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    elif question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    # shark
    # Check user permission: can vote?
    perm = question.get_permissions(user)
    if not perm or not models.Question.VOTE & perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = "Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    app.logger.debug("request.json = %s\n", request.json)

    '''
    We either use an endorsement type returned from the client to set the endorsement or
    the NORMALISED coordinates from the triangular votemap when compared to the
    threshold for the current generation of this question.
    '''

    # Check if using votemap to calculate endorsement type
    if 'use_votemap' in request.json and request.json['use_votemap']:
        app.logger.debug('Endorsing using votemap coordinates')
        # Check for coords

        if not 'coords' in request.json:
            message = {"message": "Using votemap: No votemap coordinates received"}
            return jsonify(message), 403

        coords = request.json['coords']

        if not coords['mapx'] or not coords['mapy']:
            message = {"message": "Using votemap: No votemap coordinates received"}
            return jsonify(message), 403

        # Calculate endorsement type from coords
        mapx = float(coords['mapx'])
        mapy = float(coords['mapy'])

        # Fetch current threshold coordinates for this generation
        threshold = question.thresholds\
            .filter(models.Threshold.generation == question.generation).one()

        if not threshold:
            app.logger.debug('No threshold found for question! Database out of date?')
            message = {"message": "No threshold was found for this question"}
            return jsonify(message), 500

        if mapy > threshold.mapy:
            endorsement_type = 'confused';
        elif mapx < threshold.mapx:
            endorsement_type = 'oppose';
        else:
            endorsement_type = 'endorse';

        # Add user endorsement
        proposal.endorse(user, endorsement_type, coords=coords)
        db_session.commit()
    else:
        app.logger.debug('Endorsing using supplied endorsement type')
        if not 'endorsement_type' in request.json:
            message = {"message": "You must set endorsement_type if not using votemap coordinates"}
            return jsonify(message), 400
        elif not request.json['endorsement_type'] in ENDORSEMENT_TYPES:
            message = {"message": "endorsement_type must be one of endorse, oppose or confused"}
            return jsonify(message), 400
        else:
            app.logger.debug("Endrsing type json parameter == %s", request.json['endorsement_type'])
            endorsement_type = request.json['endorsement_type']
            # Add user endorsement
            proposal.endorse(user, endorsement_type)
            db_session.commit()

    '''
    # Update graphs
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    '''

    return jsonify(message="Endorsement added",
                   endorsement_type=endorsement_type), 201



# Create Endorsement
#
@requires_auth
def api_add_proposal_endorsement_v1(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsements

        Endorse a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/endorsements HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Endorsement added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json endorsement_type: one of endorse, oppose or confused
        :json comments: ids of supported comments
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_endorsement called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    elif question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    # if proposal.is_endorsed_by(user):
    #    message = {"message": "User has already endorsed this proposal"}
    #    return jsonify(message), 400

    app.logger.debug("request.json = %s\n", request.json)

    endorsement_type = 'endorse'
    if 'endorsement_type' in request.json:
        if not request.json['endorsement_type'] in ENDORSEMENT_TYPES:
            message = {"message": "endorsement_type must be one of endorse, oppose or confused"}
            return jsonify(message), 400
        else:
            app.logger.debug("Endrsing type json parameter == %s", request.json['endorsement_type'])
            endorsement_type = request.json['endorsement_type']

    # add voting map coordinates if any
    coords = request.json.get('coords', {'mapx': None, 'mapy': None})

    app.logger.debug("endorsement_type = %s\n", endorsement_type)
    app.logger.debug("vote coords = %s\n", coords)

    # Add user endorsement
    proposal.endorse(user, endorsement_type, coords=coords)
    db_session.commit()

    '''
    # Update graphs
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    '''

    return jsonify(message="Endorsement added"), 201


# Update Endorsement
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
           '<int:proposal_id>/endorsements',
           methods=['PATCH'])
@requires_auth
def api_update_proposal_endorsement(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsements

        Update an endorsement.

        **Example request**:

        .. sourcecode:: http

            PATCH /questions/45/proposals/47/endorsements HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "message": "Endorsement updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json endorsement_type: one of endorse, oppose or confused
        :statuscode 200: no error
        :statuscode 400: bad request
        :statuscode 500: server error
    '''
    app.logger.debug("api_update_proposal_endorsement called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not found"), 400

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        message = {"message": "Your request is missing parameters"}
        return jsonify(message), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)
    elif question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    # shark
    # Check user permission: can vote?
    perm = question.get_permissions(user)
    if not perm or not models.Question.VOTE & perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = "Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    if not proposal.is_endorsed_by(user):
        message = {"message": "User has not yet endorsed this proposal"}
        return jsonify(message), 400

    if not 'endorsement_type' in request.json or not request.json['endorsement_type'] in ENDORSEMENT_TYPES:
        message = {"message": "endorsement_type must be one of endorse, oppose or confused"}
        return jsonify(message), 400

    update_proposal = proposal.update_endorsement(user, request.json['endorsement_type'])

    if update_proposal:
        return jsonify(message="Endorsement updated"), 200
    else:
        return jsonify(message="Failed to update endorsement"), 500

#
# Create proposal
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals', methods=['POST'])
@requires_auth
def api_create_proposal(question_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals

        Create a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/api/v1/questions/45/proposals/1"
            }

        :param question_id: question ID
        :type question_id: int
        :json title: proposal title
        :json blurb: proposal content
        :json abstract: proposal abstract
        :json source: parent proposal ID
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not found"), 400

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None:
        abort(400)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    # shark
    # Check user permission: can propose?
    perm = question.get_permissions(user)
    if not perm or not models.Question.PROPOSE & perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to propose on question %s", user.id, perm, question.id)
        return jsonify(message = "Question not found"), 404

    if not request.json:
        app.logger.debug("Non json request received...\n")
        abort(400)

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_PROPOSAL_TITLE:
        return jsonify(message="Proposal title must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_TITLE) + " characters"), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_PROPOSAL_BLURB:
        return jsonify(message="Proposal content must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_BLURB) + " characters"), 400

    elif 'abstract' in request.json and \
            len(request.json['abstract']) > MAX_LEN_PROPOSAL_ABSTRACT:
        return jsonify(message="Proposal abstract name must less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    title = request.json.get('title')
    blurb = request.json.get('blurb')
    abstract = request.json.get('abstract', '')

    source = 0
    if 'source' in request.json:
        if not isinstance(request.json['source'], int):
            message = {"message": "source parameter invalid"}
            return jsonify(message), 400
        elif not models.Proposal.query.get(int(request.json['source'])):
            message = {"message": "source proposal not found"}
            return jsonify(message), 400
        else:
            source = request.json['source']

    proposal = models.Proposal(user, question, title, blurb, abstract, source)
    db_session.add(proposal)
    db_session.commit()

    return jsonify(proposal=proposal.get_public()), 201


# Delete proposal
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['DELETE'])
@requires_auth
def api_delete_proposal(question_id, proposal_id):
    '''
    .. http:delete:: questions/(int:question_id)/proposals/(int:proposal_id)

        Delete a proposal.

        **Example request**:

        .. sourcecode:: http

            DELETE questions/34/proposals/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Proposal deleted"
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: user not authorized
        :statuscode 403: action forbidden
        :statuscode 404: question or proposal not found
    '''
    app.logger.debug("api_delete_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not found"), 401

    # Check user permission: can vote?
    question = models.Question.query.get(question_id)
    if question is None:
        return jsonify(message = "Question not found"), 404

    '''
    perm = question.get_permissions(user)
    if not perm or not models.Question.PROPOSE & perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to delete a proposal on question %s", user.id, perm, question.id)
        return jsonify(message = "Question not found"), 404
    '''

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify(message = "Proposal not found"), 404

    num_votes = len(proposal.all_voters(generation=proposal.question.generation))
    if num_votes > 0:
        message = {"message": "This proposal has votes and may no longer be deleted"}
        return jsonify(message), 403
    
    if user.id != proposal.user_id:
        message = {"message": "Only the author delete this proposal"}
        return jsonify(message), 403

    '''
    if proposal.question.phase != 'writing'\
            or proposal.question.generation != proposal.generation_created:
        message = {"message": "This proposal may no longer be deleted"}
        return jsonify(message), 403
    '''

    user.delete_proposal(proposal)
    db_session.commit()
    return jsonify(message="Proposal deleted"), 200


# Delete Question
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>', methods=['DELETE'])
@requires_auth
def api_delete_question(question_id):
    '''
    .. http:post:: /questions/(int:question_id)

        Delete a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/34 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "message": "Question deleted"
            }

        :param question_id: question ID
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_delete_question called for question %s...\n",
                     question_id)

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    # Cannot delete a question if not author
    if user.id != question.user_id:
        message = {"message":
                   "You are not authorized to delete this question"}
        return jsonify(message), 403

    # Cannot delete a question which has proposals
    if question.proposals.count() > 0:
        message = {"message":
                   "This question has proposals and may no longer be deleted"}
        return jsonify(message), 403

    db_session.delete(question)
    db_session.commit()
    return jsonify(message="Question deleted"), 200


# Edit Question
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>', methods=['PATCH'])
@requires_auth
def api_edit_question(question_id):
    '''
    .. http:post:: /questions/(int:question_id)

        Update a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/33 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Question updated"
            }

        :param question_id: question ID
        :type question_id: int
        :json title: question title
        :json blurb: question content
        :json room: question room
        :json minimum_time: minimum time before question can be moved on
        :json maximum_time: maximum time before question is automatically moved on
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_edit_question called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not found"}
        return jsonify(response), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None:
        return jsonify(message="Question ID not set"), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message="Question does not exist"), 404

    user_id = user.id

    # Cannot edit a question if not author
    if user_id != question.user_id:
        message = {"message": "Only the author can edit this question"}
        return jsonify(message), 403
    
    # doom
    if 'move_to_results' in request.json:
        question.phase = 'results'
        db_session.commit()
        return jsonify(message="Qustion now in results phase",
                       phase=question.phase), 200
    
    if 'move_on' in request.json:
        phase = question.author_move_on(user_id)
        db_session.commit()

        if not phase:
            return 500
        else:
            return jsonify({"question": question.get_public()}), 200

    # Cannot edit a question which has proposals
    if question.proposals.count() > 0:
        message = {"message":
                   "This question has proposals and may no longer be edited"}
        return jsonify(message), 405

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_QUESTION_TITLE:
        message = {"message": "Missing or empty title field"}
        return jsonify(message), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_QUESTION_BLURB:
        message = {"message": "Missing or empty content field"}
        return jsonify(message), 400

    question.title = request.json.get('title')
    question.blurb = request.json.get('blurb')

    db_session.add(question)
    db_session.commit()
    return jsonify(message="Question updated"), 200


# Edit proposal
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['PATCH'])
@requires_auth
def api_edit_proposal(question_id, proposal_id):
    '''
    .. http:patch:: questions/int:question_id/proposals/int:proposal_id

        Edit proposal.

        **Example request**:

        .. sourcecode:: http

            PATCH questions/22/proposals/14 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Proposal updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json title: title
        :json blurb: question content
        :json abstract: optional abstract
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_edit_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not found"}
        return jsonify(response), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None or 'proposal_id' is None:
        response = {"message": "Requires Question ID"}
        return jsonify(response), 400
    
    if 'proposal_id' is None:
        response = {"message": "Requires Proposal ID"}
        return jsonify(response), 400

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_PROPOSAL_TITLE:
        return jsonify(message="Proposal title must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_PROPOSAL_BLURB:
        return jsonify(message="Proposal content must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    elif 'abstract' in request.json and \
            len(request.json['abstract']) > MAX_LEN_PROPOSAL_ABSTRACT:
        return jsonify(message="Proposal abstract name must less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    title = request.json.get('title')
    blurb = request.json.get('blurb')
    abstract = request.json.get('abstract', None)

    question = models.Question.query.get(int(question_id))
    if question is None:
        response = {"message": "Question not found"}
        return jsonify(response), 400
    
    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        response = {"message": "Proposal not found"}
        return jsonify(response), 400

    if user.id != proposal.user_id:
        message = {"message": "You are not authorized to edit this proposal"}
        return jsonify(message), 403

    num_votes = len(proposal.all_voters(generation=proposal.question.generation))
    if num_votes > 0:
        message = {"message": "This proposal has votes and may no longer be edited"}
        return jsonify(message), 403
    
    # It is OK to update the proposal
    if proposal.update(user, title, blurb, abstract):
        db_session.commit()
        message = {"message": "Proposal updated"}
        return jsonify(message), 200
    else:
        message = {"message": "There was an error updating this proposal"}
        return jsonify(message), 400

# Get users not yet invited to participate in a question
@app.route(REST_URL_PREFIX + '/users/associated_users',
           methods=['GET'])
@requires_auth
def api_associated_users():
    '''
    .. http:get:: /users/associated_users

        A list of associared users not yet invited to participate in a question.

        **Example request**:

        .. sourcecode:: http

            GET /users/2/associated_users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_associated_users called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    question_id = request.args.get('ignore_question', None)

    if not question_id:
        message = "You must pass the question ID" %\
                  question_id
        return jsonify(message=message), 401

    app.logger.debug("api_associated_users ignore question with ID %s", question_id)

    # If a question id is given, check it question exists.
    # If not then abort
    question = models.Question.query.get(int(question_id))
    if question is None:
        message = "Question with ID %s does not exist" %\
                  question_id
        return jsonify(message=message), 400

    not_invited = user.get_uninvited_associated_users(question=question)

    return jsonify(question_id=str(question.id),
                   num_items=str(len(not_invited)),
                   not_invited=not_invited), 200


# Get users not yet invited to participate in a question
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/not_invited',
           methods=['GET'])
@requires_auth
def api_not_invited(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/not_invited

        A list of users not yet invited to participate in a question.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/not_invited HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_not_invited called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    not_invited = user.get_uninvited_associated_users(question)

    return jsonify(question_id=str(question.id),
                   num_items=str(len(not_invited)),
                   not_invited=not_invited), 200

# Get users not yet invited to participate in a question
# @app.route(REST_URL_PREFIX + '/questions/<int:question_id>/not_invited',
#           methods=['GET'])
@requires_auth # added
def api_not_invited_1(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/not_invited

        A list of users not yet invited to participate in a question.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/not_invited HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_not_invited called...\n")

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    not_invited = question.get_not_invited()

    return jsonify(question_id=str(question.id),
                   num_items=str(len(not_invited)),
                   not_invited=not_invited), 200

# Get Question Participants
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/permissions',
           methods=['GET'])
@requires_auth # added
def api_get_question_participants(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/permissions

        A list of question invitee permissions.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/proposals/67/permissions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_question_participants called...\n")

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    permissions = question.get_participant_permissions()

    return jsonify(question_id=str(question.id),
                   num_items=str(len(permissions)),
                   permissions=permissions), 200

# Get Proposal Endorsers
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
           '<int:proposal_id>/endorsers',
           methods=['GET'])
@requires_auth # added
def api_get_question_proposal_endorsers(question_id, proposal_id):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsers

        A list of proposal endorsers.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/proposals/67/endorsers HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :query generation: question generation, default is 1
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_question_proposal_endorsers called...\n")

    if question_id is None or proposal_id is None:
        app.logger.debug("ERROR: question_id or proposal_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    endorsers = proposal.endorsers(generation=generation)

    results = []
    for e in endorsers:
        results.append(e.get_public())

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(endorsers)), endorsers=results), 200


#
# Get Pareto Front
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/pareto', methods=['GET'])
@requires_auth # added
def api_question_pareto(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/pareto

        The pareto front of a question. Order by voting preference.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "proposals": [
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills Second Proposal",
                  "url": "/api/v1/questions/1/proposals/2",
                  "abstract": "This is too abstract for an abstract",
                  "created": "2013-08-15 18:32:00.176816",
                  "id": "2",
                  "blurb": "Bills blurb of varying disinterest",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/2",
                  "title": "Susans Only Proposal",
                  "url": "/api/v1/questions/1/proposals/3",
                  "abstract": "Blah blah blah",
                  "created": "2013-08-15 18:32:00.194978",
                  "id": "3",
                  "blurb": "My blub is cool",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/5",
                  "title": "Harrys Cooler Proposal",
                  "url": "/api/v1/questions/1/proposals/4",
                  "abstract": null,
                  "created": "2013-08-15 18:32:00.228671",
                  "id": "4",
                  "blurb": "Harry edits like a champ",
                  "generation_created": "1"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_pareto called with %s...\n", question_id) # final winners
    
    user = get_authenticated_user(request)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    pareto = question.calculate_pareto_front(generation=generation)
    pareto_list = list(pareto)
    pareto_list_sorted = sorted(pareto_list, key=lambda x: x.geomedx, reverse=True)

    results = []
    for p in pareto_list_sorted:
        results.append(p.get_public(user))

    app.logger.debug('pareto data ====> %s', results)

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(pareto)),
                   proposals=results), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/results', methods=['GET'])
@requires_auth # added
def api_question_results(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/results

        The final results for this question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/results HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "current_generation": "1", 
              "results": [
                {
                  "medx": 0.640694,
                  "medy": 0.395, 
                  "author": "bill", 
                  "relations": 
                  {
                    "dominated": [], 
                    "pareto": true, 
                    "dominating": [2, 4], 
                    "understood": false
                  }, 
                  "title": "Bills First Proposal"
                }, 
                {
                  "medx": 0.625, 
                  "medy": 0.175, 
                  "author": "susan", 
                  "relations": 
                  {
                    "dominated": [], 
                    "pareto": true, 
                    "dominating": [], 
                    "understood": true
                  }, 
                  "title": "Susans Only Proposal"
                }
              ], 
              "question_id": "44"
            }

        :param question_id: question id
        :statuscode 200: no error
        :statuscode 404: bad request
    '''
    app.logger.debug("api_question_results called with questiobn ID %s...\n",
                     question_id) # final
    
    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        jsonify(message="Question ID not set in request"), 404

    question = models.Question.query.get(int(question_id))

    if not question.phase is 'results':
        app.logger.debug("ERROR: Question must be in results phase before returning the results!\n")
        jsonify(message="Question not in results phase"), 404

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    
    results = list()
    all_relations = question.calculate_proposal_relation_ids()
    endorsement_results = question.get_endorsement_results()

    for (proposal_id, relations) in all_relations.iteritems():
        if relations['pareto']:
            proposal = models.Proposal.query.get(proposal_id)
            relations['dominated'] = list(relations['dominated'])
            relations['dominating'] = list(relations['dominating'])
            results.append({'relations': relations, 
                            'medx': endorsement_results[proposal_id]['median']['medx'],
                            'medy': endorsement_results[proposal_id]['median']['medy'],
                            'title': proposal.title,
                            'author': proposal.author.username})
                                    
    '''
    votes = question.all_votes_by_type()
    for (proposal_id, all_votes) in votes.iteritems():
        results[proposal_id] = dict()
        results[proposal_id]['votes'] = all_votes
    '''
    
    app.logger.debug("final results: %s", results)
    
    return jsonify(question_id=str(question.id),
                   current_generation=str(question.generation),
                   results=results), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/participation_table', methods=['GET'])
@requires_auth # added
def api_question_participation_table(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/participation_table

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_participation_table called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    participants = question.get_participants()
    app.logger.debug("participants==> %s", participants)
    all_proposals = question.get_all_proposals()
    
    authors = dict()
    for proposal in all_proposals:
        if proposal.author.id not in authors:
            authors[proposal.author.id] = 1
        else:
            authors[proposal.author.id] = authors[proposal.author.id] + 1
    
    '''
    participants
    [{'permissions': '7', 'user_id': '1', 'username': u'john'},
     {'permissions': '7', 'user_id': '2', 'username': u'susan'},
     {'permissions': '7', 'user_id': '3', 'username': u'bill'},
     {'permissions': '7', 'user_id': '4', 'username': u'jack'}]
     
     all_proposals
     [<Proposal(9 'Bill's stuff' by bill, Q:'2')>,
     <Proposal(10 'dfsdfsdfds' by bill, Q:'2')>]
     
     authors
     {1: 1, 2: 0}
     
     {"num_proposals": "2", "current_generation": "1", "question_id": "2", "num_items": "1", 
     "participation_table": [{"username": "bill", "past_generations": 0, "evaluations": 0}]}
     
     {"num_proposals": "2", "current_generation": "1", "question_id": "2", "num_items": "1", 
     "participation_table": [
        {"username": "bill", "evaluations": 0, "authored": 2}
        {"username": "john", "evaluations": 0, "authored": 0}
        {"username": "jack", "evaluations": 0, "authored": 1}
     ]}
    '''

    participation_table = []
    for user in participants:
        participant = dict()
        participant['username'] = user.username
        participant['evaluations'] = user.get_endorsement_count(question)
        
        if user.id not in authors:
            participant['proposals_written'] = 0
        else:
            participant['proposals_written'] = authors[user.id]
        
        app.logger.debug("participant==>%s", participant)
        participation_table.append(participant)
        app.logger.debug("participation_table==>%s", participation_table)

    return jsonify(question_id=str(question.id),
                   current_generation=str(question.generation),
                   num_proposals=str(len(all_proposals)),
                   num_items=str(len(participation_table)),
                   participation_table=participation_table), 200

# @app.route(REST_URL_PREFIX + '/questions/<int:question_id>/participation_table', methods=['GET'])
@requires_auth # added
def api_question_participation_table_v1(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/participation_table

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_participation_table called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    participants = set()

    # key_players = question.calculate_key_players()
    all_proposals = question.get_all_proposals()

    all_voters = set()
    all_authors = set()
    for proposal in all_proposals:
        all_authors.add(proposal.author)
        all_voters.update(proposal.all_voters())

    participants.update(all_authors)
    participants.update(all_voters)

    app.logger.debug("participants==> %s", participants)

    participation_table = []
    for user in participants:
        participant = dict()
        participant['username'] = user.username
        # participant['key_player'] = user in key_players
        participant['past_generations'] = user.generations_participated_count(question)
        participant['evaluations'] = user.get_endorsement_count(question)
        app.logger.debug("participant==>%s", participant)
        participation_table.append(participant)
        app.logger.debug("participation_table==>%s", participation_table)

    return jsonify(question_id=str(question.id),
                   current_generation=str(question.generation),
                   num_proposals=str(len(all_proposals)),
                   num_items=str(len(participation_table)),
                   participation_table=participation_table), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/key_players', methods=['GET'])
@requires_auth # added
def api_question_key_players(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/key_players

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_key_players called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    generation = int(request.args.get('generation', question.generation))
    key_players = question.calculate_key_players(generation=generation)

    app.logger.debug("calculate_key_players returned: %s", key_players)
    # {3: set([<Proposal('3', Q:'1')>, <Proposal('4', Q:'1')>]), 4: set([<Proposal('3', Q:'1')>])}

    results = []
    for (endorser, vote_for) in key_players.iteritems():
        # Need to initialize values to stop knockout.js complaining
        proposals = {'notvoted': [], 'oppose': [], 'confused': []}
        for proposal in vote_for:
            endorse_type = proposal.get_endorsement_type(endorser)
            # if endorse_type not in proposals:
                # proposals[endorse_type] = list()
            proposals[endorse_type].append(proposal.id)
        kp = {'user': endorser.get_public(), 'add_vote': proposals}
        results.append(kp)

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(key_players)), key_players=results), 200


#@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/key_players', methods=['GET'])
def api_question_key_players_v1(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/key_players

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_key_players called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    generation = int(request.args.get('generation', question.generation))
    key_players = question.calculate_key_players(generation=generation)

    app.logger.debug("calculate_key_players returned: %s", key_players)
    # {3: set([<Proposal('3', Q:'1')>, <Proposal('4', Q:'1')>]), 4: set([<Proposal('3', Q:'1')>])}

    results = []
    for (endorser, vote_for) in key_players.iteritems():
        proposals = []
        for proposal in vote_for:
            # proposals.append(url_for('api_get_question_proposals',
            #                         question_id=question.id,
            #                         proposal_id=proposal.id))
            proposals.append(proposal.id)
        kp = {endorser: proposals}
        results.append(kp)

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(key_players)), key_players=results), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/endorser_effects',
           methods=['GET'])
@requires_auth # added
def api_question_endorser_effects(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/endorser_effects

        A list of endorser effects.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/endorser_effects HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "objects": [
                {
                  "5": {}
                },
                {
                  "4": {
                    "PF_excluding": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/2",
                        "title": "Susans Only Proposal",
                        "url": "/api/v1/questions/1/proposals/3",
                        "abstract": "Blah blah blah",
                        "created": "2013-08-15 18:32:00.194978",
                        "id": "3",
                        "blurb": "My blub is cool",
                        "generation_created": "1"
                      }
                    ],
                    "PF_plus": [],
                    "PF_minus": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/5",
                        "title": "Harrys Cooler Proposal",
                        "url": "/api/v1/questions/1/proposals/4",
                        "abstract": null,
                        "created": "2013-08-15 18:32:00.228671",
                        "id": "4",
                        "blurb": "Harry edits like a champ",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "3": {
                    "PF_excluding": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/5",
                        "title": "Harrys Cooler Proposal",
                        "url": "/api/v1/questions/1/proposals/4",
                        "abstract": null,
                        "created": "2013-08-15 18:32:00.228671",
                        "id": "4",
                        "blurb": "Harry edits like a champ",
                        "generation_created": "1"
                      }
                    ],
                    "PF_plus": [],
                    "PF_minus": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/3",
                        "title": "Bills Second Proposal",
                        "url": "/api/v1/questions/1/proposals/2",
                        "abstract": "This is too abstract for an abstract",
                        "created": "2013-08-15 18:32:00.176816",
                        "id": "2",
                        "blurb": "Bills blurb of varying disinterest",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "1": {}
                }
              ],
              "num_items": "5",
              "question_id": "1"
            }

        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_endorser_effects called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    endorser_effects = question.\
        calculate_endorser_effects(generation=generation)

    app.logger.debug("Endorser Effects==> %s", endorser_effects)

    results = []
    for (endorser, effects) in endorser_effects.iteritems():
        endorser_effects = dict()

        if not effects is None:
            PF_excluding_pulbic = replaceWithPublic(effects['PF_excluding'])
            PF_plus_public = replaceWithPublic(effects['PF_plus'])
            PF_minus_public = replaceWithPublic(effects['PF_minus'])

            endorser_effects = {
                'PF_excluding': PF_excluding_pulbic,
                'PF_plus': PF_plus_public,
                'PF_minus': PF_minus_public}
        else:
            endorser_effects = {}

        results.append({endorser.id: endorser_effects})

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(results)), objects=results), 200


def replaceWithPublic(collection):
    public = []
    for c in collection:
        public.append(c.get_public())
    return public


#
# Get graph
#
# http://[hostname]/api/v1.0/questions/47/graph?generation=2&map_type=pareto
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/graph', methods=['GET'])
@requires_auth # added
def api_question_graph(question_id):
    '''
    .. http:get:: questions/(int:question_id)/graph

        Get the Voting map for this generation.

        **Example request**:

        .. sourcecode:: http

              GET /questions/42/graph?graph_type=pareto&genration=3 HTTP/1.1
              Host: example.com
              Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
             "question_id": 42,
             "graph_generation": 3,
             "graph_type": "all",
             "current_generation": 4,
             "url": "/maps/map_Q42_G4_all_1_1.svg"
            }

        :param question_id: question ID
        :type question_id: int
        :query map_type: map type. default is all generation proposals
        :type map_type: string: either "all" or "pareto", defaults to "all"
        :query generation: question generation
        :type generation: int
        :query proposal_level_type: proposal node layout, defaults to "layers"
        :type proposal_level_type: string: one of "layers", "num_votes" or "flat"
        :query user_level_type: user node layout, defaults to "layers"
        :type user_level_type: string: one of "layers", "num_votes" or "flat"

        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_graph called...\n")

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))

    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    app.logger.debug("api_question_graph: ************** USING ALGORITHM %s ************", algorithm)

    # app.logger.debug('Question has %s endorsememnts', question.has_endorsememnts(generation))
    if not question.has_endorsememnts(generation=generation):
        app.logger.debug("Question has no endorsements in generation %s", generation)
        return jsonify(message="No endorsements yet"), 204

    map_type = request.args.get('map_type', 'all')
    proposal_level_type = request.args.get('proposal_level_type',
                                           models.GraphLevelType.layers)
    user_level_type = request.args.get('user_level_type',
                                       models.GraphLevelType.layers)

    '''
    filename_hashed = models.make_map_filename_hashed(question=question,
                                                      generation=generation,
                                                      map_type=map_type,
                                                      proposal_level_type=proposal_level_type,
                                                      user_level_type=user_level_type)
    app.logger.debug('filename_hashed ==> %s', filename_hashed)'''

    app.logger.debug("Call get_voting_graph()...")


    if algorithm == 1:
        graph_svg = question.get_voting_graph(
            generation=generation,
            map_type=map_type,
            proposal_level_type=proposal_level_type,
            user_level_type=user_level_type)
    else:
        graph_svg = question.get_complex_voting_graph(
            generation=generation)

    if not graph_svg:
        message = "There was a problem creating the graph"
        return jsonify(message=message), 500

    return jsonify(question_id=str(question.id),
                   map_type=map_type,
                   graph_generation=str(generation),
                   current_generation=str(question.generation),
                   url=app.config['PROTOCOL'] + app.config['SITE_DOMAIN'] + '/' + app.config['EXTERNAL_MAP_PATH'] +
                       graph_svg,
                   proposal_level_type=proposal_level_type,
                   user_level_type=user_level_type), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/voting_data',
           methods=['GET'])
@requires_auth
def api_get_voting_data(question_id):
    '''
    .. http:post:: questions/(int:question_id)/voting_data

        A map of voting results for a question.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/voting_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_results called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    # Check user permission
    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not found"), 400
        
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access voting_data for question %s", user.id, question.id)
        return jsonify(message = "Question not found"), 404
    
    generation = int(request.args.get('generation', question.generation))

    voting_data = question.get_endorsement_results(generation)

    # app.logger.debug("results ==> %s", results)

    return jsonify(
        question_id=str(question.id),
        current_generation=str(question.generation),
        requested_generation=str(generation),
        num_items=str(len(voting_data)),
        voting_data=voting_data), 200

@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/voting_map',
           methods=['GET'])
@requires_auth # added
def api_question_voting_map(question_id):
    '''
    .. http:post:: questions/(int:question_id)/voting_map

        A map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/voting_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_voting_map called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))

    voting_map = question.voting_map()

    # app.logger.debug("voting_map=====>%s", voting_map)

    return jsonify(
        question_id=str(question.id),
        current_generation=str(question.generation),
        num_items=str(len(voting_map)),
        voting_map=voting_map), 200

@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/levels_map',
           methods=['GET'])
@requires_auth # added
def api_question_levels_map(question_id=None):
    '''
    .. http:post:: questions/(int:question_id)/levels_map

        A map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/levels_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_levels_map called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    levels =\
        question.calculate_levels_map(generation=generation, algorithm=algorithm)
    app.logger.debug("levels=====>%s", levels)

    levels_map = []
    for (proposal_id, levels) in levels.iteritems():
        levels_map.append({"id": proposal_id, "levels": levels})

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(levels_map)),
        levels_map=levels_map), 200

@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/domination_map',
           methods=['GET'])
@requires_auth # added
def api_question_domination_map(question_id=None):
    '''
    .. http:post:: questions/(int:question_id)/domination_map

        A map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/domination_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_domination_map called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    # domination_map =\
    #     question.calculate_domination_map(generation=generation, algorithm=algorithm)

    relations =\
        question.calculate_domination_map(generation=generation, algorithm=algorithm)
    keys = relations.keys()
    app.logger.debug("Domination Map: keys ==> %s", keys)

    app.logger.debug("Domination Map: relations ==> %s", relations)

    domination_map = []

    for (proposal_id, dominations) in relations.iteritems():

        '''
        app.logger.debug("Processing relations for proposal %s", proposal.id)
        app.logger.debug("%s Dominated ==>%s", proposal.id, relations['dominated'])
        app.logger.debug("%s Dominating ==>%s", proposal.id, relations['dominating'])
        '''
        '''
        doms = []
        for (pid, relation) in dominations.iteritems():
            doms.append({"pid": pid, "relation": relation})
        '''
        # app.logger.debug("dominations===>>>>> %s", dominations)

        app.logger.debug("Dom Table Symbols: %s", DOMINATION_MAP_SYMBOLS)
        domination_list = []
        for pid in keys:
            domination_list.append( DOMINATION_MAP_SYMBOLS[ dominations[pid] ] )
        domination_map.append({"id": int(proposal_id), "dominations": domination_list})

        # app.logger.debug("domination_map==>%s", domination_map)

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(domination_map)),
        domination_map=domination_map), 200

@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposal_relations',
           methods=['GET'])
@requires_auth # added
def api_question_proposal_relations(question_id=None):
    '''
    .. http:post:: questions/(int:question_id)/proposal_relations

        A list of proposal relations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/proposal_relations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "objects": [
                {
                  "3": {
                    "dominating": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/3",
                        "title": "Bills First Proposal",
                        "url": "/api/v1/questions/1/proposals/1",
                        "abstract": null,
                        "created": "2013-08-13 10:42:55.625328",
                        "id": "1",
                        "blurb": "Bills blurb of varying interest",
                        "generation_created": "1"
                      }
                    ],
                    "dominated": []
                  }
                },
                {
                  "2": {
                    "dominating": [],
                    "dominated": []
                  }
                },
                {
                  "1": {
                    "dominating": [],
                    "dominated": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/2",
                        "title": "Susans Only Proposal",
                        "url": "/api/v1/questions/1/proposals/3",
                        "abstract": "Blah blah blah",
                        "created": "2013-08-13 10:42:55.664450",
                        "id": "3",
                        "blurb": "My blub is cool",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "4": {
                    "dominating": [],
                    "dominated": []
                  }
                }
              ],
              "num_items": "4",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_proposal_relations called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    proposal_relations =\
        question.calculate_proposal_relations(generation=generation)

    app.logger.debug("Proposal Relations==> %s", proposal_relations)

    results = []
    for (proposal, relations) in proposal_relations.iteritems():
        dominated_public = replaceWithPublic(relations['dominated'])
        dominating_public = replaceWithPublic(relations['dominating'])

        prop_relations = {
            'dominated': dominated_public,
            'dominating': dominating_public}

        results.append({proposal.id: prop_relations})

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(proposal_relations)), proposal_relations=results), 200


# Get Invitations
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/invitations',
           methods=['GET'])
@requires_auth # added
def api_get_invitations(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/invitations

        A list of invitations for a question.

        **Example request**:

        .. sourcecode:: http

            GET /questions/45/invitations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "total_items": "4",
              "items": "2",
              "objects": [
                {
                  "receiver_id": "/api/v1/users/2",
                  "sender_url": "/api/v1/users/1",
                  "sender_id": 1,
                  "id": "1",
                  "question_id": 1
                },
                {
                  "receiver_id": "/api/v1/users/3",
                  "sender_url": "/api/v1/users/1",
                  "sender_id": 1,
                  "id": "2",
                  "question_id": 1
                }
              ],
              "page": "1",
              "pages": "2"
            }

        :param question_id: question ID
        :type question_id: int
        :query page: results page number, default is 1
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_invitations called...\n")

    if question_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    page = int(request.args.get('page', 1))

    invites = models.Invite.query.filter(
        models.Invite.question_id == int(question_id)).\
        paginate(page, RESULTS_PER_PAGE, False)

    items = len(invites.items)
    pages = invites.pages
    total_items = invites.total

    results = []
    for i in invites.items:
        results.append(i.get_public())

    return jsonify(total_items=str(total_items), items=str(items),
                   page=str(page), pages=str(pages),
                   invitations=results), 200


# Create Email Invitation
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/emailinvitations',
           methods=['POST'])
@requires_auth
def api_create_email_invitation(question_id):
    '''
    .. http:post:: questions/(int:question_id)/emailinvitations

        Create invitations to a question.

        **Example request**:

        .. sourcecode:: http

            POST questions/45/invitations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Invites sent"
            }

        :param question_id: question id
        :type question_id: int
        :json invite_user_ids: list of user ids to invite
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_email_invitation called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    if question_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    if not request.json:
        abort(400)

    if not 'user_emails' in request.json:
        abort(400)

    permissions = int(request.json.get('permissions', models.Question.READ))
    user_emails = request.json['user_emails']
    email_list = user_emails.split(',')

    rejected = list()
    accepted = list()
    already_sent = list()
    invites_count = 0

    for email in email_list:
        email = email.strip()
        if not '@' in email:
            app.logger.debug("@ not found in %s", email)

            if email not in rejected:
                rejected.append(email)
            continue
        else:
            instance = db_session.query(models.EmailInvite)\
                .filter(and_(models.EmailInvite.receiver_email == email,
                             models.EmailInvite.sender_id == user.id,
                             models.EmailInvite.question_id == question.id))\
                .first()
            if instance:
                app.logger.debug("Address %s already contacted", email)
                if email not in already_sent:
                    already_sent.append(email)
                continue
            else:
                accepted.append(email)
                token = uuid.uuid4().get_hex()
                new_invite = models.EmailInvite(user, email, permissions, question_id, token)

                # send email aesynchronously - (Check sent)
                emails.send_question_email_invite_email(user, email, question, token)
                new_invite.email_sent = 1

                db_session.add(new_invite)
                invites_count = invites_count + 1
                # Send email
                # email_question_email_invite(user, email, question)

    if invites_count:
        db_session.commit()

    addresses_already_sent = ",".join(already_sent)
    rejected_addresses = ",".join(rejected)
    accepted_addresses = ",".join(accepted)
    invites = {'question_id': str(question_id),
                'accepted': accepted_addresses,
                'rejected': rejected_addresses,
                'already_sent': addresses_already_sent,
                'num_invites_sent': str(invites_count)}

    return jsonify(invites=invites), 201


# Create Invitation
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/invitations',
           methods=['POST'])
@requires_auth
def api_create_invitation(question_id):
    '''
    .. http:post:: questions/(int:question_id)/invitations

        Create invitations to a question.

        **Example request**:

        .. sourcecode:: http

            POST questions/45/invitations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Invites sent"
            }

        :param question_id: question id
        :type question_id: int
        :json invite_user_ids: list of user ids to invite
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_invitation called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None:
        abort(404)

    if not request.json:
        abort(400)

    if not 'invite_user_ids' in request.json:
        abort(400)

    invite_user_ids = request.json['invite_user_ids']

    permissions = int(request.json.get('permissions', models.Question.READ))

    for id in invite_user_ids:
        try:
            id = int(id)
        except ValueError:
            app.logger.debug(
                "Param invite_user_ids contains non integer values!\n")
            abort(400)

    app.logger.debug("invite_user_ids = %s\n", invite_user_ids)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    app.logger.debug("calling invite_all with users %s\n", invite_user_ids)
    if user.invite_all(invite_user_ids, permissions, question):
        app.logger.debug("invites created\n")
        db_session.commit()
        return jsonify(message="Invites created"), 201
    else:
        abort(500)


# Get subscriptions
#
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions', methods=['GET'])
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions/<int:question_id>',
           methods=['GET'])
@requires_auth # added
def api_get_user_subscriptions(user_id, question_id=None):
    '''
    .. http:get:: users/(int:user_id)/subscriptions

        A subscription or list of subscriptions to a question.

        **Example request**:

        .. sourcecode:: http

            GET users/12/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "total_items": 3,
              "items": 2,
              "objects": [
                {
                  "url": "/users/1/subscriptions/1",
                  "how": "asap",
                  "last_update": "None",
                  "question_id": "1"
                },
                {
                  "url": "/users/1/subscriptions/2",
                  "how": "asap",
                  "last_update": "None",
                  "question_id": "2"
                }
              ],
              "page": "1",
              "pages": "2"
            }

        :param user_id: user id
        :type user_id: int
        :param question_id: question id
        :type question_id: int
        :query page: page number, defaults to 1
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_user_subscriptions called...\n")

    if user_id is None:
        abort(404)

    user = models.User.query.get(int(user_id))

    if question_id is not None:

        subscribed_question = user.subscribed_questions.\
            filter(models.Update.question_id == int(question_id)).one()

        if subscribed_question is None:
            abort(404)

        app.logger.debug("Subscribed question ID %s\n",
                         subscribed_question.question_id)
        '''
        subscriptions = [{'question_id': subscribed_question.question_id,
                          'how': subscribed_question.how,
                          'last_update': str(subscribed_question.last_update)}]
        '''
        results = [subscribed_question.get_public()]
        return jsonify(object=results), 200

    else:
        page = int(request.args.get('page', 1))
        subscribed_questions = user.subscribed_questions.\
            paginate(page, RESULTS_PER_PAGE, False)
        items = len(subscribed_questions.items)
        pages = subscribed_questions.pages
        total_items = subscribed_questions.total

        results = []
        for s in subscribed_questions.items:
            results.append(s.get_public())

        return jsonify(total_items=total_items, items=(items),
                       page=str(page), pages=str(pages),
                       subscriptions=results), 200


#
# Create Subscription
#
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions', methods=['POST'])
@requires_auth
def api_add_user_subscriptions(user_id):
    '''
    .. http:post:: /users/(int:user_id)/subscriptions

        Create a subscription.

        **Example request**:

        .. sourcecode:: http

            POST /users/22/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "url": "/api/v1/users/1/subscriptions/1"
            }

        :param user_id: user id
        :type user_id: int
        :json question_id: question id
        :json how: one of daily, weekly, or asap
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
    '''
    app.logger.debug("api_add_user_subscriptions called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if not request.json:
        abort(400)

    if not 'how' in request.json\
            or not request.json['how'] in ['daily', 'weekly', 'asap']:
        abort(400)

    if not 'question_id' in request.json:
        abort(400)

    question_id = int(request.json['question_id'])
    how = request.json['how']

    if user.subscribed_questions.filter(
            models.Update.question_id == question_id).count() == 1:
        abort(400)

    question = models.Question.query.get(question_id)
    if question is None:
        abort(400)

    user.subscribe_to(question, how)
    db_session.add(user)
    db_session.commit()

    return jsonify({'url': url_for('api_get_user_subscriptions',
                                   user_id=user_id,
                                   question_id=question_id)}), 201


#
# Update subscription
#
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions',
           methods=['PATCH'])
@requires_auth
def api_update_user_subscriptions(user_id):
    '''
    .. http:patch:: /users/(int:user_id)/subscriptions

        Update a user's question subscription'.

        **Example request**:

        .. sourcecode:: http

            PATCH users/56/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "objects": [
                {
                  "how": "asap",
                  "last_update": "None",
                  "question_id": 3
                }
              ]
            }

        :param user_id: user id
        :type user_id: int
        :json question_id: question id
        :json how: one of daily, weekly, or asap
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
    '''
    app.logger.debug("api_update_user_subscriptions called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if not request.json:
        abort(400)

    if user_id is None:
        abort(400)

    if user.id != user_id:
        abort(401)

    if not 'question_id' in request.json:
        msg_txt = "You must supply the parameter 'question_id' " +\
                  "set to the id of the question" +\
                  "you wish to subscribe to"
        message = {"message": msg_txt}
        return jsonify(message), 400

    question_id = int(request.json['question_id'])

    if not 'how' in request.json \
            or not request.json['how'] in ['daily', 'weekly', 'asap']:
        msg_txt = "You must supply the parameter 'how' " +\
                  "set to one of the desired" +\
                  "update methods: 'daily', 'weekly', 'asap'"
        message = {"message": msg_txt}
        return jsonify(message), 400

    subscription = user.subscribed_questions.\
        filter(models.Update.question_id == int(question_id)).first()

    if subscription is None:
        abort(404)

    subscription.how = request.json['how']
    # db_session.add(user)
    db_session.commit()

    subscription = [{'question_id': subscription.question_id,
                    'how': subscription.how,
                    'last_update': str(subscription.last_update)}]

    return jsonify(objects=subscription), 201


# Delete subscription
#
# @app.route(REST_URL_PREFIX + '/subscriptions/<int:question_id>',
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions/<int:question_id>',
           methods=['DELETE'])
@requires_auth
def api_delete_user_subscriptions(user_id, question_id):
    '''
    .. http:delete:: /users/(int:user_id)/subscriptions/(int:question_id)

        Delete a question subscription.

        **Example request**:

        .. sourcecode:: http

            DELETE users/56/subscriptions/44 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
            "message": "Subscription Deleted"
            }

        :param user_id: user id
        :type user_id: int
        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_delete_user_subscriptions called...\n")

    user = get_authenticated_user(request)

    if user is None:
        abort(404)

    if user_id is None:
        abort(400)

    if user.id != user_id:
        abort(401)

    if question_id is None:
        abort(404)

    app.logger.debug("Authenticated User = %s\n", user.id)

    subscription = user.subscribed_questions.filter(and_(
        models.Update.question_id == int(question_id),
        models.Update.user_id == user.id)).first()

    if subscription is not None:
        user.subscribed_questions.remove(subscription)
    db_session.add(user)
    db_session.commit()
    return jsonify(message="Subscription deleted"), 200
