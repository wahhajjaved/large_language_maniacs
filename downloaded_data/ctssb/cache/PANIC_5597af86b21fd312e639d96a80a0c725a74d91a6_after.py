#    "$Name:  $";
#    "$Header:  $";
#=============================================================================
#
# file :        PyAlarm.py
#
# description : Python source for the PyAlarm and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PyAlarm are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  sergi_rubio at cells$
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :   ALBA Synchrotron Light Facility
#                Barcelona
#                Europe
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================

import sys
import os
import time
import threading
import traceback
import re
import collections

import PyTango
import fandango
import fandango.tango
import fandango.functional as fun
from fandango.log import except2str,shortstr
from fandango.objects import __lock__, self_locked,Singleton
from fandango.dicts import defaultdict_fromkey
try:
    from fandango.threads import WorkerProcess,getPickable
    PROCESS = True
except: 
    PROCESS = False

# It should work only in PyTango7
# if 'PyUtil' not in dir(PyTango):
    #PyTango.PyDeviceClass = PyTango.DeviceClass
    #PyTango.PyUtil = PyTango.Util

try: __RELEASE__ = open(os.path.dirname(os.path.abspath(__file__))+'../VERSION').read().strip()
except Exception,e: __RELEASE__ = '?.?'
print '> PyAlarm %s'%__RELEASE__

###############################################################################
# Checking Dependencies

try:
    import panic 
except:
    print 'Unable to load panic module: %s'%traceback.format_exc()

try:
    try: import panic.extra.smslib as smslib
    except:
      try: import albasmslib as smslib
      except:
        import smslib
    SMS_ALLOWED=True
    print('Using smslib from %s'%smslib.__file__)
except Exception,e: 
    print('UNABLE TO LOAD SMSLIB ... SMS MESSAGING DISABLED: ',str(e))
    SMS_ALLOWED=False

try:
    from PyTangoArchiving import snap
    SNAP_ALLOWED=True
except Exception,e:
    print('UNABLE TO LOAD SNAP ... SNAP ARCHIVING DISABLED: ',str(e))
    SNAP_ALLOWED=False
#The device is not ready yet for Snapshoting
#SNAP_ALLOWED=False

USE_STATIC_METHODS = getattr(PyTango,'__version_number__',0)<722

###############################################################################

class SingletonTangoEval(fandango.tango.TangoEval,Singleton):
    #All processes must use the same TangoEval object
    pass

class AlarmHook(fandango.Object):
    """
    This class identifies an Action to be executed as response to an alarm.
    :param condition:   a boolean function that will return True if this action is appliable to the given argument.
                        e.g. (condition=lambda s: '@' in s) will apply for mail addresses
    :param action:      function([tag,receivers,...]) to be executed when the action is applied.
    """
    def __init__(self,condition=None,action=None):
        self._condition = condition
        self._action = action
        pass
    def match(self,argument):
        """This method will apply the given condition to the argument. Overridable in subclasses"""
        return self._condition(argument)
    def apply(self,tag,receivers):
        """This method will apply the given action to the argument. Overridable in subclasses"""
        return self._action(tag,receivers)


#==================================================================
#   PyAlarm Class Description:
#
#         This device server is used as a alarm logger, it connects to the list of attributes provided and verifies its values.<br />
#         Its focused on notifying Alarms by log files, Mail, SMS and (some day in the future) electronic logbook.<br />
#         It allows to setup alarms based on attribute values, connection status and boolean combinations of them.<br />
#         Independent configuration and mailing lists available for each alarm.<br/>
#         You can acknowledge these alarms by a proper command.<br />
#         <p>This device requires <a href="http://www.tango-controls.org/Documents/tools/fandango/fandango">Fandango module<a> to be available in the PYTHONPATH.</p>
#
#==================================================================
#     Device States Description:
#
#   DevState.ON :     ActiveAlarms list is empty
#   DevState.ALARM :  Size of ActiveAlarms is >=1
#==================================================================


class PyAlarm(PyTango.Device_4Impl, fandango.log.Logger):

    #--------- Add your global variables here --------------------------

    Panic = None

    MAX_SMS_DAY = 20

    MESSAGE_TYPES = ['ALARM','ACKNOWLEDGED','RECOVERED','REMINDER','AUTORESET','RESET','DISABLED']
    
    #--------------------------------------------------------------------------
    ##Overriding Quality-based Tango state machine
    def set_state(self,state):
        self._state = state
        PyTango.Device_4Impl.set_state(self,state)
    def get_state(self):
        #@Tango6
        #This have been overriden as it seemed not well managed when connecting devices in a same server
        return self._state
    def dev_state(self):
        #@Tango7
        #This have been overriden to avoid device servers with states managed by qualities
        return self._state
    def State(self):
        """ State redefinition is required to keep independency between 
        attribute configuration (max/min alarms) and the device State """
        #return self.get_state()
        return self._state    
    
    def set_status(self,status):
        self._status = status
        PyTango.Device_4Impl.set_status(self,status)
    def get_status(self,status):
        return self._status
    def dev_status(self):
        return self._status
    def Status(self):
        return self._status
    
    #--------------------------------------------------------------------------

    def alarm_attr_read(self,attr,fire_event=True):
        """
        This is the method where you control the value assignt to each Alarm attributes
        """
        tag_name = attr.get_name()
        value = any(re.match(tag_name.replace('_','.')+'$',a) for a in self.get_active_alarms())
        self.debug('PyAlarm(%s).read_alarm_attribute(%s) is %s; Active Alarms: %s' % (self.get_name(),tag_name,value,self.get_active_alarms()))
        
        self.quality=PyTango.AttrQuality.ATTR_WARNING
        if(self.Alarms[tag_name].severity=='DEBUG'):
            self.quality=PyTango.AttrQuality.ATTR_VALID
        elif(self.Alarms[tag_name].severity=='WARNING'):
            self.quality=PyTango.AttrQuality.ATTR_WARNING
        elif(self.Alarms[tag_name].severity=='ALARM' or self.Alarms[tag_name].severity=='ERROR'):
            self.quality=PyTango.AttrQuality.ATTR_ALARM
        else: self.quality=PyTango.AttrQuality.ATTR_WARNING
        
        attr.set_value_date_quality(value,time.time(),self.quality)
    
    if USE_STATIC_METHODS: alarm_attr_read = staticmethod(self_locked(alarm_attr_read))

    def alarm_attr_allowed(self,req_type):
        """
        Alarms should be always readable, the quality of the alarm will change if needed
        """
        return True
    if USE_STATIC_METHODS: alarm_attr_allowed = staticmethod(alarm_attr_allowed)

    def create_alarm_attribute(self,argin):
        new_attr_name = self.Alarms[argin].get_attribute()
        if new_attr_name in self.DynamicAttributes:
            self.info('PyAlarm(%s): attribute %s already exists' % (self.get_name(),new_attr_name))
        else:
            self.info('PyAlarm(%s): Creating attribute %s for %s alarm' % (self.get_name(),new_attr_name,argin))
            self.add_attribute(PyTango.Attr(new_attr_name,PyTango.ArgType.DevBoolean,PyTango.AttrWriteType.READ),
                self.alarm_attr_read,
                None, #self.write_new_attribute #(attr)
                self.alarm_attr_allowed
                )
            self.DynamicAttributes.append(new_attr_name)
        return new_attr_name
        
    def update_locals(self,_locals=None,check=True,update=False):
        if _locals is None: _locals = {}
        try:
            _locals.update(dict(zip('DOMAIN FAMILY MEMBER'.split(),self.get_name().split('/'))))
            _locals.update({'DEVICE':self.get_name(),'ALARMS':self.Alarms.keys(),'PANIC':self.Panic,'SELF':self})
            _locals.update({'t':time.time() - (self.TStarted+self.StartupDelay)})
            if not check: update = True #If check is True locals will be updated only if necessary or forced
            if check:
                for k,v in self.Alarms.items():
                    val = v.active if not self.CheckDisabled(k) else False
                    if _locals.get(k,None)!=val: update = True
                    _locals[k] = val
            if update:
                self.debug('In PyAlarm.update_locals(...)')
                if self.worker:
                    try:
                        self.worker.send('update_locals',
                            target='update_locals',
                            args={'dct':dict((k,v) for k,v in _locals.items() if k in self.Panic)},
                            callback=None)
                    except: 
                        self.error('worker.send(update_locals) failed!: %s'%traceback.format_exc())
                        self.info(str(_locals))
                else: 
                    self.Eval.update_locals(_locals)
                    if self.get_name()+'/'+self.Alarms.keys()[0] not in self.Eval.attributes:
                        self.Eval.attributes.update(dict((str(n).lower(),fandango.tango.CachedAttributeProxy(n,fake=True))
                            for n in (self.get_name()+'/'+k for k in self.Alarms) ))
                    [self.Eval.attributes[self.get_name()+'/'+k].set_cache(_locals[k]) for k in self.Alarms]
        except:
            self.warning(traceback.format_exc())
        return _locals

    def dyn_attr(self):
        ## Dynamic Attributes Creator
        self.debug( '#'*40)
        self.info( 'In PyAlarm(%s).dyn_attr()'%self.get_name())
        alarms = self.Alarms.keys()# if hasattr(self,'Alarms') else [a.tag for a in self.panic.get(device=self.get_name())]
        self.update_locals(dict.fromkeys(self.Panic.keys()),check=False,update=True) # Done here to avoid subprocess triggering exceptions
        
        for alarm in alarms:
            try:
                self.create_alarm_attribute(alarm)
                if self.worker: 
                    self.worker.add(alarm,'eval',
                        {'formula':self.Alarms[alarm].formula,'_raise':True},
                        period=self.PollingPeriod,
                        expire=self.AlarmThreshold*self.PollingPeriod)
            except:
                self.warning( 'Unable to create %s attribute'%alarm)
                self.warning( traceback.format_exc())
        self._initialized = True
        return

    ###########################################################################
    
    def parse_receivers(self,tag_name='',filtre=False,receivers=None):
        '''
        Filters the Alarm receivers matching tag_name; also replaces addresses entered in the PhoneBook 
        This method is called from free_alarm and send_alarm.
        '''
        if tag_name not in self.Alarms: return []
        if receivers is None:
            raw_receivers = self.Alarms[tag_name].receivers.split('#')[0]
            receivers = self.Alarms.parse_phonebook(raw_receivers)
            self.debug( 'In parse_receivers: %s replaced by %s' % (raw_receivers,receivers))
        else: receivers = ','.join(receivers)
        receivers = [r for r in receivers.split(',') if not filtre or filtre in r]
        self.debug( 'In parse_receivers(%s): receivers added: %s' % (tag_name,receivers))
        return receivers
        
    def parse_action_receivers(self,tag_name,message,receivers):
        '''
        Filters the alarm receivers extracting ACTION(...) formulas.
        Extracts arguments from every action and return them as a list.
        '''
        actions = []
        re_arglist = '(?:'+'(?:[^()]*)'+'|'+'(?:[^()]*\([^()]*\)[^()]*)'+')'
        if fun.isSequence(receivers): receivers = ','.join(receivers)
        action_receivers = re.findall('ACTION\('+re_arglist+'\)',receivers)
        for ac in action_receivers:
            t = {'DISABLED':'disable','ACKNOWLEDGED':'acknowledge'}.get(message,message.lower())
            #rm = re.search(t.lower()+':((?:.*?)|(?:.*[\(].*[\)].*))'+'[\;\)]',ac)
            #rm = re.search(t.lower()+':('+re_arglist+')[\;\)]',ac)
            rm = re.search('(?:'+t.lower()+'|[*]):'+'('+re_arglist+')[\;\)]',ac)
            if rm: actions.append(rm.group(1))
        self.info('parse_action_receivers(%s,%s): %s'%(tag_name,message,receivers))
        return actions

    ##@name Thread management methods
    # @{

    def start(self):
        if self.updateThread:
            if self.updateThread.isAlive():
                self.warning( 'Start not allowed, thread still working')
                return
            else: del self.updateThread
        self.info( 'Thread Starting')
        self.event.clear()
        self.updateThread = threading.Thread(None,self.updateAlarms,'PyAlarm')
        self.updateThread.setDaemon(True)
        self.updateThread.start()

    def stop(self):
        self.info( 'In PyAlarm.stop() ...')
        self.event.set()
        self.updateThread.join(self.PollingPeriod)
        if self.updateThread.isAlive():
            self.warning( 'Thread '+self.updateThread.getName()+' doesn''t Stop!')
        else:
            self.warning( 'Thread '+self.updateThread.getName()+' Stop')
        if self.worker and self.worker.isAlive(): self.worker.stop()
        return
    ##@}

    ###########################################################################
    
    def get_enabled(self, force=False):
        e = str(self.Enabled).lower().strip()
        last = self.PastValues.get('Enabled',(0,0))
        t = int(time.time() - (self.TStarted+self.StartupDelay))
        if not force and t-last[0] < self.PollingPeriod: return last[1]
        if e in ('true','1','yes','enabled'): r = True
        elif e in ('','false','0','no','none','disabled'): r = None
        elif e=='nan': r = fandango.NaN
        elif fandango.matchCl('^[0-9]+$',e): r = t > int(e)
        else: #Evaluating an alarm formula
            try:
                self.FailedAlarms.pop('Enabled',None)
                r = self.EvaluateFormula(self.Enabled,as_string=False,_locals={'t':t})
            except:
                self.FailedAlarms['Enabled'] = traceback.format_exc()
                print(self.FailedAlarms['Enabled'])
                r = False
        self.PastValues['Enabled'] = t,r
        return r

        
    
    def get_last_values(self,alarm='',variables=None):
        if self.worker:
            # Getting the values of variables
            previous = self.worker.get('previous')
            try: 
                #self.debug('previous values: %s'%previous.keys())
                if variables is None: variables = self.Eval.parse_variables(self.Alarms[alarm].formula)
                formula = self.Alarms[alarm].formula if alarm in self.Alarms else ''
                VALUE = dict((k,v) for k,v in previous.items() if any(fun.searchCl(self.Eval.parse_tag(v[0]+'/'+v[1],'.'),k) for v in variables))
                VALUE.update((a,bool(v.active)) for a,v in self.Alarms.items() if a in formula)
            except Exception,e: 
                self.warning('Exception parsing values: %s'%traceback.format_exc()) #except2str(e))
                VALUE = {'Exception':str(previous)}
            return VALUE
        else:
            #get_target = lambda v: v[0] + (v[1] and '/%s'%v[1]) + (v[2] and '.%s'%v[2])
            #self.Eval.last.update(dict((get_target(v),'...') for v in variables if v not in self.Eval.last))
            return self.Eval.last
    
    
    def updateAlarms(self):
        self.info( 'In PyAlarm::updateAlarms ...')
        self.event.clear()
        polled_attrs = []
        #Alarms will not start evaluation until StartupDelay seconds has passed.
        if time.time()<(self.TStarted+self.StartupDelay):
            self.info('Alarms evaluation not started yet, waiting StartupDelay=%d seconds.'%self.StartupDelay)
            self.event.wait(self.StartupDelay-(time.time()-self.TStarted))
        #Checking that the background test process is running
        if self.worker:
            if not self.worker.isAlive(): self.worker.start()
            self.event.wait(self.PollingPeriod)
        #Initializing alarm values used in formulas
        _locals = self.update_locals()
            
        while not self.event.isSet():
            try:
                try:
                    #self.Alarms.servers.db.get_info()
                    fandango.tango.get_database_device().state()
                except:
                    self.warning('Tango database is not available!\n%s'%traceback.format_exc())
                    self.set_state(PyTango.DevState.FAULT)
                    ## This wait is here just to prevent the loop to spin continuously
                    # The update_locals command will not allow background process to die
                    for k in self.Alarms.servers:
                        self.event.wait(self.PollingPeriod/len(self.Alarms.servers))
                        if self.worker: _locals = self.update_locals(_locals,update=True)
                    continue

                ###############################################################
                try:
                    self.lock.acquire()
                    timewait = float(self.PollingPeriod)/(len(self.Alarms) or 1.)
                    self.info( 'updateAlarms(): timewait between polling is %f s'%timewait)
                    myAlarms = sorted(a for a in self.Alarms.items() if not self.CheckDisabled(a[0])) #copied without disabled alarms
                finally: 
                    self.lock.release()
                self.info('\n\n'+
                    'Enabled alarms to process in next %d s cycle (UseProcess=%s): %s ' % (self.PollingPeriod,self.UseProcess,[a[0] for a in myAlarms])
                    +'\n'+'#'*80)
                if not self.get_enabled(force=True): self.info( 'ALARM SENDING IS DISABLED!!')
                ###############################################################
                # NOT using a subProcess and Using Taurus to update the variables
                if not self.worker and self.UseTaurus:
                    try: #When using Taurus it will minimize the CPU usage
                        import taurus
                        tpolling = max((250,1e3*self.PollingPeriod/2.))
                        self.info('\tSet taurus polling period = %d ms'%tpolling)
                        for a in taurus.Factory().tango_attrs.keys():
                            if a not in polled_attrs:
                                polled_attrs.append(a)
                                TA = taurus.Attribute(a)
                                try:
                                    TA.activatePolling(tpolling,force=True)
                                except:
                                    self.warning('\tThis Taurus release doesnt allow to force polling!')
                                    TA.changePollingPeriod(tpolling)
                    except Exception,e: 
                        self.debug('\tunable to set taurus polling period: %s'%e)
                        #self.warning(traceback.format_exc())
                elif self.worker:
                    self.info('Worker last alive at %s: %s,%s'%(time.ctime(self.worker.last_alive),self.worker._process.is_alive(),self.worker._receiver.is_alive()))
                ###############################################################
                    
                for tag_name,alarm in myAlarms: #Format is:    TAG3:LT/VC/Dev1/Pressure > 1e-4
                    now = self.last_attribute_check = time.time()
                    ######################################################################################################################
                    self.debug('\n\n'+'%s: Reading alarm tag %s; formula: %s'%(now,tag_name,alarm.formula)+'\n'+'-'*80)
                    variables = {}
                    VALUE = self.EvaluateFormula(alarm.formula,tag_name=tag_name,as_string=False,lock=True,_locals=_locals,variables=variables)
                        
                    #Wait moved out of try/except to avoid locked waits.
                    if VALUE is None and tag_name in self.FailedAlarms:
                        self.event.wait(timewait)
                        continue

                    if VALUE:
                        # The alarm condition is ACTIVE
                        ###################################################
                        WAS_OK = alarm.counter<self.AlarmThreshold
                        # counter and active will not have same values if the alarm is not acknowledged for a while
                        if WAS_OK:
                            #Alarm counters are not increased above Threshold
                            alarm.counter+=1
                        self.info('Alarm %s triggered for %d/%d cycles'%(tag_name,alarm.counter,self.AlarmThreshold))

                        if alarm.counter>=self.AlarmThreshold:
                            # Sending ALARM
                            ########################################################
                            if not alarm.active:
                                #Alarm is sent only if it was not active or it was recovered and just came back to alarm or has passed the reminder cycle
                                self.set_alarm(tag_name)
                                self.LastAlarms.append(time.ctime(now)+': '+tag_name)
                                self.PastValues[tag_name] = variables.copy() if hasattr(variables,'copy') else None #Storing the values that will be sent in the report
                                if alarm.tag not in self.AcknowledgedAlarms: self.send_alarm(tag_name,message='ALARM',values=variables or None) # <=== HERE IS WHERE THE ALARM IS SENT!

                            # Sending REMINDER
                            ########################################################
                            elif not alarm.acknowledged and self.Reminder and ((alarm.recovered and WAS_OK and self.AlertOnRecovery) or alarm.last_sent<(now-self.Reminder)):
                                    self.info('==========> ALARM %s reminder is sent after %s seconds being active.'%(alarm.tag,self.Reminder))
                                    if alarm.tag not in self.AcknowledgedAlarms: self.send_alarm(tag_name,message='REMINDER',values=variables or None)
                            alarm.recovered = 0
                    else:
                        # The alarm is NOT active
                        ###################################################
                        if alarm.counter: 
                            alarm.counter-=1
                        if not alarm.counter and alarm.active: #The alarm condition was active in the previous cycle
                            self.PastValues[tag_name] = variables.copy() if hasattr(variables,'copy') else None #Storing the values that will be sent in the report
                            # Alarm RECOVERED
                            #####################################################
                            if not alarm.recovered:
                                self.info('The alarm is still active ... but values came back to reality!')
                                alarm.recovered = now
                                if self.AlertOnRecovery and alarm.tag not in self.AcknowledgedAlarms: 
                                    self.send_alarm(tag_name,message='RECOVERED',values=variables)
                            # Alarm AUTO-RESET
                            #####################################################
                            elif self.AutoReset and alarm.recovered<(now-self.AutoReset):
                                    self.info('==========> ALARM %s has been reset automatically after %s seconds being inactive.'%(alarm.tag,self.AutoReset))
                                    self.free_alarm(alarm.tag,notify=False)
                                    if alarm.tag not in self.AcknowledgedAlarms: self.send_alarm(tag_name,message='AUTORESET',values=variables)

                    self.debug( 'Alarm %s counter is : %s' %(tag_name, alarm.counter))
                    if tag_name in self.FailedAlarms: self.FailedAlarms.pop(tag_name)
                    self.lock.acquire()
                    self.Alarms[tag_name]=alarm
                    self.lock.release()
                    ######################################################################################################################
                    self.event.wait(timewait)
                if not myAlarms: self.event.wait(timewait)
                self.Uncatched=''

            except Exception,e:
                from traceback import format_exc
                tr=format_exc()
                self.error( 'Uncatched exception in PyAlarm::updateAlarmsThread:\n%s'%tr + '\n' + '='*80)
                self.Uncatched+=tr+'\n'
                self.event.wait(timewait)
        self.info( 'In updateAlarms(): Thread finished')
        return

    #@self_locked
    def set_alarm(self,tag_name):
        result = False
        self.debug( '#'*80)
        self.info( 'In set_alarm(%s)'%tag_name)
        try:
            self.lock.acquire()
            if not self.Alarms[tag_name].active:
                self.Alarms[tag_name].active = time.time()
                self.Alarms[tag_name].recovered = 0
                result = True
            self.update_flag_file()
            self.update_log_file()
        finally:
            self.lock.release()
        return result

    def get_active_alarms(self):
        return [k for k,v in self.Alarms.items() if v.active]

    #@self_locked
    def free_alarm(self,tag_name,comment='',message=None, notify=True):
        """ message for freeing alarm must be RESET/ACKNOWLEDGED/DISABLED """
        try:
            self.lock.acquire()
            self.info('-'*80),self.info('In free_alarm(%s,%s,%s,%s)'%(tag_name,comment,message,notify))
            result = False
            alarm_obj = self.Alarms[tag_name]
            receivers = self.parse_receivers(tag_name)
            was_active = alarm_obj.active
            if message=='RESET' and self.CheckDisabled(tag_name): 
                self.Enable(tag_name)
            if not was_active:
                result = False
            else:
                if message!='ACKNOWLEDGED': #RESETING THE ALARM (Acknowledge just puts it in "Silent mode")
                    date = self.Alarms[tag_name].active
                    self.PastAlarms[date].append(tag_name)
                    self.PastValues[tag_name] = None #Storing the values that triggered the alarm
                    self.Alarms[tag_name].clear()
                    if tag_name in self.AcknowledgedAlarms: self.AcknowledgedAlarms.remove(tag_name)
        except:
            self.warning( 'ResetAlarm(%s) failed!: %s' % (tag_name,traceback.format_exc()))
        finally:
            self.lock.release()
        try: #NOTIFICATION SHOULD NOT BE WITHIN THE LOCK
            if was_active:
                if self.get_enabled() and notify:
                    print '\treceivers: %s'%receivers
                    
                    ## Actions must be evaluated first in case rapid action is needed
                    action_receivers = self.parse_action_receivers(tag_name,message,receivers)
                    if action_receivers:
                        self.info('checking %s actions ... %s'%(message,action_receivers))
                        for ac in action_receivers:
                            try:
                                self.trigger_action(alarm_obj,ac)
                            except:
                                self.warning( 'PyAlarm.trigger_action crashed with exception:\n%s' % traceback.format_exc())
                        
                    try:
                        self.SendMail(self.GenerateReport(tag_name,self.parse_receivers(tag_name,'@',receivers),message=message or 'RESET',user_comment=comment))
                    except Exception,e:
                        self.warning( 'PyAlarm.SendMail crashed with exception:\n%s' % traceback.format_exc())
                      
                    try:
                        if SNAP_ALLOWED and (self.UseSnap or self.parse_receivers(tag_name,'SNAP',receivers)): 
                            self.info('>'*80+'\n'+'triggering snapshot for alarm:'+tag_name)
                            self.trigger_snapshot(tag_name, user_comment=comment)
                    except Exception, e:
                        self.warning( 'PyAlarm.trigger_snapshot crashed with exception:\n%s' % traceback.format_exc())
                    
                    try:
                        if self.parse_receivers(tag_name,'HTML',receivers):
                            self.info('>'*80+'\n'+'saving html report for alarm:'+tag_name)
                            self.SaveHtml(self.GenerateReport(tag_name,message=message or 'RESET',user_comment=comment, html=True))
                    except Exception, e:
                        self.warning( 'PyAlarm.saveHtml crashed with exception:\n%s' % traceback.format_exc())
            
            self.update_flag_file()
            self.update_log_file()
        except:
            self.warning( 'ResetAlarm(%s) failed!: %s' % (tag_name,traceback.format_exc()))
        self.info('-'*80)
        return result

    #########################################################################################################
    ##@name Alarm Sending
    #@{

    def send_alarm(self,tag_name,message='',values=None):
        """
        This method parses receivers and:
         - Sends email/SMS for alarms
         - Sends email/sms for RECOVERED/REMINDER if specified in AlertOnRecovery property
         - Triggers snapshots for ALARMS
         - Saves HTML report
         
        ACKNOWLEDGE/RESET messages are not managed here, but in free_alarm
        """
        self.info('-'*80)
        self.info(shortstr('In PyAlarm.send_alarm(%s,%s,%s)'%(tag_name,message,values),255))
        try:
            if self.Alarms[tag_name].sent >= self.MaxMessagesPerAlarm: #This counter is reset calling .clear() from free_alarm()
                self.debug('*'*80)
                self.warning('Too many alarms (%d) already sent for %s!!!' % (self.Alarms[tag_name].sent, tag_name))
                self.debug('*'*80)
                return
            if message in ('ALARM','REMINDER') or self.AlertOnRecovery:
                try:
                    self.lock.acquire()
                    receivers = self.parse_receivers(tag_name)
                    mail_receivers = self.parse_receivers(tag_name,'@',receivers)
                    sms_receivers = self.parse_receivers(tag_name,'SMS',receivers)
                    action_receivers = self.parse_action_receivers(tag_name,message,receivers)
                    self.info('receivers:'+';'.join(str(r) for r in (receivers,mail_receivers,sms_receivers,action_receivers)))
                finally:
                    self.lock.release()

                if self.get_enabled():
                    if self.Alarms[tag_name].severity=='DEBUG':
                        self.info('%s Alarm with severity==DEBUG do not trigger actions, messages or snapshot'%tag_name)
                    else:
                        ## ACTIONS MUST BE EVALUATED FIRST PRIOR TO NOTIFICATION
                        if action_receivers:
                            self.info('checking %s actions ... %s'%(message,action_receivers))
                            for ac in action_receivers:
                                try:
                                    self.trigger_action(self.Alarms[tag_name],ac)
                                except:
                                    self.warning( 'PyAlarm.trigger_action crashed with exception:\n%s' % traceback.format_exc())                      
                        if mail_receivers: 
                            try:
                                self.SendMail(self.GenerateReport(tag_name,mail_receivers,message=message,values=values))
                            except:
                                self.debug('-'*80)
                                self.warning('Exception sending email!: %s' % traceback.format_exc())
                        #Disabling sms message for those messages not related to new alarms
                        if sms_receivers and message in ('ALARM',) or 'sms' in str(self.AlertOnRecovery).lower(): 
                            try:
                                self.SendSMS(tag_name,sms_receivers,message=message,values=values)
                            except:
                                self.debug('-'*80)
                                self.warning('Exception sending sms!: %s' % traceback.format_exc())
                        if self.parse_receivers(tag_name,'HTML',receivers):
                            try:
                                self.info('saving html report for alarm:'+tag_name)
                                self.SaveHtml(self.GenerateReport(tag_name,message=message,values=values, html=True))
                            except Exception, e:
                                self.warning('PyAlarm.saveHtml crashed with exception:\n%s' % traceback.format_exc())
                        if (message in ('ALARM','ACKNOWLEDGED','RESET') or self.AlertOnRecovery and message=='RECOVERED') \
                                and SNAP_ALLOWED and (self.UseSnap or self.parse_receivers(tag_name,'SNAP',receivers)):
                            try:
                                self.info('<'*80+'\n'+'triggering snapshot for alarm:'+tag_name)
                                if (self.Alarms[tag_name].severity!='DEBUG'): self.trigger_snapshot(tag_name,message)
                            except Exception, e:
                                self.warning('PyAlarm.trigger_snapshot crashed with exception:\n%s' % traceback.format_exc())

                else:
                    self.info('=============> ALARM SENDING DISABLED!!')

                self.Alarms[tag_name].sent += 1
                self.Alarms[tag_name].last_sent = time.time()
        except Exception,e:
            self.warning('PyAlarm.send_alarm crashed with exception:\n%s' % traceback.format_exc())
        self.info('-'*80)
        return

    def update_flag_file(self):
        ''' If there's Active Alarms writes a 1 to the file specified by FlagFile property, else writes 0 '''
        try:
            self.lock.acquire()
            AlarmsToNotify = self.get_active_alarms()
            self.info( 'update_flag_file: Writing %s to %s' % ('1\n' if AlarmsToNotify else '0\n' ,self.FlagFile))
            f=open(self.FlagFile,'w')
            f.writelines(['1\n' if AlarmsToNotify else '0\n'])
            f.close()
        except Exception,e:
            self.warning( 'Exception in PyAlarm.update_flag_file: %s' % traceback.format_exc())
        finally:
            self.lock.release()

    def update_log_file(self):
        if not hasattr(self,'LogFile') or not self.LogFile or self.LogFile.strip()=='/dev/null': return
        try:
            self.lock.acquire()
            f=open(self.LogFile,'a')
            report = []
            report.append('%s PyAlarm Device Server at %s\n\n' % (self.get_name(),time.ctime()))
            if self.get_active_alarms():
                report.append('Active Alarms are:\n')
                [report.append('\t%s:%s:%s\n'%(k,time.ctime(self.Alarms[k].active),self.Alarms[k].formula)) for k in self.get_active_alarms()]
            else: report.append( "There's No Active Alarms\n")
            if self.PastAlarms: 
                report.append( '\n\n' + 'Past Alarms were:' + '\n\t'.join([''] + ['%s:%s'%(','.join(k),time.ctime(d)) for d,k in self.PastAlarms.items()]) +'\n')
            f.writelines(report)
            f.close()
        except Exception,e:
            self.warning( 'Exception in PyAlarm.update_log_file: %s' % traceback.format_exc())
        finally:
            self.lock.release()

    def trigger_action(self, alarm, args):
        """  
        Executing a command on alarm/disable/reset/acknowledge: 
            ACTION(alarm:command,mach/alarm/beep/play_sequence,$DESCRIPTION)

        The syntax allow both attribute/command execution and the usage of multiple typed arguments: 
            ACTION(alarm:command,mach/dummy/motor/move,int(1),int(10))
            ACTION(reset:attribute,mach/dummy/motor/position,int(0))
        """
        if fun.isString(alarm): alarm = self.Alarms[alarm]
        action = args if fun.isSequence(args) else re.split('[,:;]',args)
        self.info('In PyAlarm.trigger_action(%s,%s)'%(alarm.tag,args))
        if action[0] in ('command','attribute'):
            try:
                dev = action[1].rsplit('/',1)[0]
                cmd = [action[1].rsplit('/',1)[1]]+action[2:]
                cmd = [c.replace('$ALARM',alarm.tag
                    ).replace('$DESCRIPTION',alarm.description
                    ).replace('$alarm',alarm.tag
                    ).replace('$description',alarm.description
                    ) for c in cmd]
                try: #This eval will allow to pass numeric/float arguments
                    arg = eval(cmd[1]) if len(cmd)==2 else [eval(c) for c in cmd[1:]]
                except: 
                    arg = cmd[1] if len(cmd)==2 else cmd[1:]
                    
                if action[0] == 'command':
                    self.info('\tlaunching: %s / %s (%s)' % (dev,cmd[0],cmd[1:]))
                    cargs = [cmd[0],arg] if arg else [cmd[0]]
                    val = PyTango.DeviceProxy(dev).command_inout(*cargs)
                    self.info('\t'+str(val))
                    
                else:
                    self.info('\tlaunching: %s / %s = %s' % (dev,cmd[0],cmd[1:]))
                    val = PyTango.DeviceProxy(dev).write_attribute(cmd[0],arg)
                    self.info('\t'+str(val))
            except:
                self.warning('Unable to execute action %s'%str(action))
                self.warning(traceback.format_exc())
        elif action[0]=='system' and action[1] in self.AllowedActions:
            try:
                os.system(action[1]+'&')
            except:
                self.warning('Unable to execute action %s'%str(action))
                self.warning(traceback.format_exc())
        else:
            self.warning('\tUnknown Action: %s'%action[0])

    ##@}
    #########################################################################################################

    ## @name Snap Contexts Methods
    #@{

    #SnapContext(359,Name,Author,Reason,Attributes[3],Snapshots[0])
    def trigger_snapshot(self,tag_name, user_comment=None):
        """
        First check for existing contexts with name=tag_name.
        If 1 exists and reason is Alarm, it is used. If reason is not, a new one is created.
        Then an snapshot is taken for the cotnext.
        """
        self.info( "In "+self.get_name()+"::trigger_snapshot(%s)"%tag_name)
        try:
            formula = self.Alarms[tag_name].formula
            self.info(formula)
            variables = self.Eval.parse_variables(formula)
            existingAttrsAllowed=[]
            for var in variables:
                if (self.snap.check_attribute_allowed(str(var[0]+'/'+var[1]))): 
                    existingAttrsAllowed.append(str(var[0]+'/'+var[1]))
    
            if (len(existingAttrsAllowed)==0):
                self.warning('Cannot take a snapshot - alarm attributes list empty!')
                return
    
            res=self.snap.db.search_context(tag_name)
            res = sorted(c for c in res if c['reason']=='ALARM')
            cids = sorted(c['id_context'] for c in res)
            
            if not res: 
                if not self.CreateNewContexts: 
                    self.warning('Automatic Context Creation DISABLED!, Sorry, use CreateAlarmContext method')
                    return
                self.info('Creating ctx: name: '+tag_name+', descr: '+formula)
                self.info('atts:')
                for a in existingAttrsAllowed:
                    self.info(a)
                cid = self.CreateAlarmContext([tag_name]+existingAttrsAllowed)
                ctx = self.snap.get_context(cid)
                self.info('snap.descr: '+formula)
            else:
                if len(res)>1: self.warning('Multiple contexts declared for this Alarm, using newest!: %s'%str(cids))
                ctx=self.snap.get_context(cids[-1])
    
            self.snap.db.update_context_attributes(self.snap.db.get_context_ids(tag_name)[0], existingAttrsAllowed)
            if user_comment and user_comment!='ALARM':
                if user_comment in ('DISABLED','RECOVERED'):
                    ctx.take_snapshot(comment=shortstr(user_comment,255))
                else: 
                    ctx.take_snapshot(comment=shortstr('ACKNOWLEDGED: %s'%user_comment,255))
            else: 
                ctx.take_snapshot(comment=shortstr('ALARM: %s'%self.Alarms[tag_name].description,255))
                
        except Exception,e:
            self.warning( 'Exception in trigger snapshot: %s' % traceback.format_exc())
        return
    ##@}

    def AddNewAlarm(self, argin):
        #@todo: This command has to be refactored and added as Expert command
        self.info( "In "+ self.get_name()+ "::AddNewAlarm()")
        #    Add your own code here
        argout = ['FAILED']
        try:
            self.lock.acquire()
            alarm = self.parse_alarm(argin)
            if not alarm:
                argout = 'INVALID ALARM FORMAT: %s'%alarm['tag']
            elif alarm['tag'] in self.Alarms:
                argout = 'ALARM TAG %s ALREADY EXISTS!'%alarm['tag']
            else:
                self.AlarmList.append(argin)
                self.init_device(update_properties=False)
                self.db.put_device_property(self.get_name(),{'AlarmList':self.AlarmList})
                argout = self.AlarmList[:]
        finally:
            self.lock.release()
        return argout

    def RemoveAlarm(self, argin):
        #@todo: This command has to be refactored and added as Expert command
        self.info("In "+self.get_name()+"::RemoveAlarm()")
        #    Add your own code here
        argout = ['FAILED']
        try:
            self.lock.acquire()
            if argin in self.Alarms and self.Alarms[argin].active: return 'ALARM SHOULD BE ACKNOWLEDGED FIRST!'
            match = [a for a in self.AlarmList if a.lower().startswith(argin.lower()+':')]
            if not match: return 'UNKNOWN ALARM TAG!'
            self.AlarmList.pop(match[0])
            self.init_device(update_properties=False)
            self.db.put_device_property(self.get_name(),{'AlarmList':self.AlarmList})
            argout = self.AlarmList[:]
        finally:
            self.lock.release()
        return argout 

    # #########################################################################################################

    ## @name POGO Generated Methods    

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)

        self.call__init__(fandango.log.Logger,name,format='%(levelname)-8s %(asctime)s %(name)s: %(message)s')
        self.setLogLevel('DEBUG')
        panic._proxies[name] = self
        fandango.tango.get_all_devices.set_keeptime(180)
        
        #Persistent data:
        self.TStarted = time.time() #Used to calcullate StartupDelay and Enabled behavior
        self.Alarms = None #dictionary for Alarm Structs
        self.FailedAlarms = fandango.CaselessDict() #This list will keep a track of those alarms that couldn't be evaluated
        self.SMS_Sent = collections.deque() #Epochs when messages has been sent
        self.Proxies = defaultdict_fromkey(lambda key: PyTango.DeviceProxy(key)) #list of proxies
        self.PastAlarms = defaultdict_fromkey(lambda key: list()) #{date1:[tag1,tag2,tag3,...],date2:...}
        self.PastValues = {} #It will store the attribute values when the alarm was triggered.

        self.AcknowledgedAlarms = set() #This list will keep a track of acknowledged alarms
        self.DisabledAlarms = {} #This list will keep a track of disabled alarms, and its timeouts
        self.LastAlarms = []
        self.SentEmails = collections.defaultdict(int)
        self.SentSMS = collections.defaultdict(int)
        
        self.Eval = None
        self.EvalTimes = {}
        self.Uncatched = ''
        self.DynamicAttributes = []
        self._initialized = False #Enabled once dyn_attr has finished

        self.worker = None
        self.lock=threading.RLock();
        self.event=threading.Event();
        self.threadname=name
        self.updateThread = None
        self.last_attribute_check = 0
        self.db = PyTango.Database()
        
        #A class object will keep all declared alarms to search for children alarms and duplications
        if type(self).Panic is None: type(self).Panic = panic.AlarmAPI()
        self.debug('Out of __init__()')

        PyAlarm.init_device(self,allow=True)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def __del__(self):
        self.info( 'In PyAlarm.__del__() method ...')
        self.delete_device(True)

    def delete_device(self,allow=False):
        self.warning( "0[Device delete_device method] for device %s"%self.get_name())
        if allow:
            self.set_state(PyTango.DevState.INIT)
            self.stop()
        if not allow: self.warning('init() is not allowed, please restart the server')

        # Do not do that or you may have seg faults!
        #print "1[Device delete_device method] for device",self.get_name()
        #for dp in self.Proxies.values(): del dp
        #print "2[Device delete_device method] for device",self.get_name()

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self,update_properties=True,allow=True):
        """
        This method will be called first for creating the device.
        It will be called afterwards to force a reloading of Alarms or Properties
        """
        self.info( "In "+self.get_name()+"::init_device()")
        if not allow: raise Exception('init() is not allowed, please restart the server')
        try:
            if update_properties or not self._initialized: 
                try:
                    #Reloading the alarm properties
                    self.lock.acquire()
                    if self.Alarms is None:
                        self.Alarms = panic.AlarmAPI(self.get_name()) #Everything that was active/inactive is erased here?
                    #This second part is not called for the first init(); only for the next ones
                    #It's just for checking if alarms has been added/removed from the API
                    else:
                        self.Alarms.load(self.get_name())
                        alarm_attrs = dict((a,v.get_attribute()) for a,v in self.Alarms.items())
                        for a in self.DynamicAttributes[:]:
                            if a not in alarm_attrs.values():
                                try:
                                    self.info('Removing %s attribute'%a)
                                    self.remove_attribute(a)
                                    self.DynamicAttributes.remove(a)
                                    if self.worker: self.worker.pop(a)
                                except:
                                    self.warning( traceback.format_exc())
                        for a,v in alarm_attrs.items():
                            if v not in self.DynamicAttributes[:]:
                                self.create_alarm_attribute(a)
                except Exception,e:
                    raise e
                finally: self.lock.release()
                self.get_device_properties(self.get_device_class())
                self.info("Current Alarm server configuration is:\n\t"+"\n\t".join(
                    sorted("%s: %s"%(k,getattr(self,k,None)) for k in 
                    panic.PyAlarmDefaultProperties)))
                
                #@TODO: Period should be in SECONDS!: this patch must be DEPRECATED
                if self.PollingPeriod>3600: 
                  self.warning('PERIODS IN MILLISECONDS ARE DEPRECATED!!!!!!!: '+
                      '%s ms >> %s s'%(self.PollingPeriod,self.PollingPeriod*1e-3))
                  self.PollingPeriod = self.PollingPeriod*1e-3 #Converting from ms to s
                if str(self.AlertOnRecovery).strip().lower() in ('false','no','none'): self.AlertOnRecovery=''
                if str(self.Reminder).strip().lower()=='false': self.Reminder=0
                
                if not self.UseTaurus:
                    fandango.tango.USE_TAU,fandango.tango.TAU = False,None
                else:
                    self.info('UseTaurus = %s'%self.UseTaurus)
                if self.Eval is None:
                    self.Eval = self.Panic._eval = (SingletonTangoEval if self.UseProcess and PROCESS else fandango.tango.TangoEval)(
                        timeout=self.EvalTimeout,keeptime=self.PollingPeriod/2.,
                        trace=False, #self.LogLevel.upper()=='DEBUG',
                        cache=1+self.AlarmThreshold, #Note, a cache too large will filter oscillations in alarms using .delta
                        use_tau=False
                        )
                    [self.Eval.add_macro(*m) for m in self.Panic.macros]
                    self.update_locals()
                    self.Eval.set_timeout(self.EvalTimeout)
                if hasattr(self.Eval,'clear'): self.Eval.clear()
                
                if self.UseProcess and PROCESS and not self.worker:
                    #Do not reduce worker timeout or you may have problems if main thread idles (e.g. Tango database is down)
                    self.info('Configuring WorkerProcess ...')
                    self.worker = WorkerProcess(self.Eval,start=True,timeout=self.PollingPeriod*max((self.AlarmThreshold,3)))
                    self.worker.send('set_timeout','set_timeout',self.EvalTimeout)
                    self.worker.command('import threading')
                    #,timewait=0.05*self.PollingPeriod/len(self.Alarms))
                    self.worker.add('previous',target='dict([(k,str(v)) for k,v in executor.previous.items()])',args='',period=self.PollingPeriod/2.,expire=self.AlarmThreshold*self.PollingPeriod)
                    if self.UseTaurus:
                        try: 
                            self.worker.command('import taurus')
                            self.worker.add('update_polling','[taurus.Attribute(a).changePollingPeriod(%d) for a in taurus.Factory().tango_attrs.keys()]'%max((500,1e3*self.PollingPeriod/2.)),period=self.PollingPeriod)
                        except: print traceback.format_exc()
                    #raise Exception,'The StartupDelay should be asynchronous!!! It cannot be called before any "command" call or will block!'
                    self.worker.pause(self.StartupDelay)
                    self.info('Configured WorkerProcess, waiting %s seconds in background ...'%self.StartupDelay)

                self.PhoneBook = self.Alarms.phonebook
                if '$NAME' in self.LogFile:
                    self.LogFile = self.LogFile.replace('$NAME',self.get_name().replace('/','-'))

            self.AddressList = dict(self.PhoneBook)

            for tag,alarm in self.Alarms.items():
                self.info('\n\t%s: %s\n\t\tFormula: %s\n\t\tSeverity: %s\n\t\tReceivers: %s'%(tag,alarm.description,alarm.formula,alarm.severity,alarm.receivers))

            #Create Alarm Attributes (not called in first init(), only afterwards
            if self._initialized: self.dyn_attr()

            #Get SnapConfig
            #if SNAP_ALLOWED and self.UseSnap:
            if SNAP_ALLOWED:
                try:
                    self.snap = snap.SnapAPI()
                except Exception,e: self.warning('SnapConfig failed: %s'%e)

            if not self._initialized: 
                self.set_state(PyTango.DevState.ON)
            if not self.updateThread or not self.updateThread.isAlive(): 
                self.start()
            self.info( 'Ready to accept request ...'+'<'*40)
            self.setLogLevel(self.LogLevel)
        except Exception,e:
            self.info( 'Exception in PyAlarm.init_device(): \n%s'%traceback.format_exc())
            self.set_state(PyTango.DevState.FAULT)
            raise e
        return

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.debug("In "+ self.get_name()+ "::always_excuted_hook()")
        try:
            actives = list(reversed([(v.active,k) for k,v in self.Alarms.items() if v.active]))
            if self.last_attribute_check and self.last_attribute_check<(time.time()-600.):
                self.set_state(PyTango.DevState.FAULT)
                self.set_status('Alarm Values not being updated!!!')
            elif self.worker and not (self.worker._process.is_alive() and self.worker._receiver.is_alive()):
                self.set_state(PyTango.DevState.FAULT)
                self.set_status('Alarm Values not being processed!!!') 
            else:
                if self.get_enabled():
                    self.set_state(PyTango.DevState.ALARM if actives else PyTango.DevState.ON)
                    status = "There are %d active alarms\n" % len(actives)
                else:
                    self.set_state(PyTango.DevState.DISABLE)
                    status = "Device is DISABLED temporarily (Enabled=%s)\n"%self.Enabled
                for date,tag_name in actives:
                    status+='%s:%s:\n\t%s\n\tSeverity:%s\n\tSent to:%s\n' % (time.ctime(date),tag_name,self.Alarms[tag_name].description,self.Alarms[tag_name].severity,self.Alarms[tag_name].receivers)
                if self.FailedAlarms:
                    status+='\n%d alarms couldnt be evaluated:\n%s'%(len(self.FailedAlarms),','.join(str(t) for t in self.FailedAlarms.items()))
                if self.Uncatched:
                    status+='\nUncatched exceptions:\n%s'%self.Uncatched
                status += '\n\n' + 'EvalTimes are: \n %s\n'%(self.EvalTimes)
                self.set_status(status)
        except:
            self.warning( traceback.format_exc())


#==================================================================
#
#    PyAlarm read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        #self.debug("In "+self.get_name()+"::read_attr_hardware()")
        pass
    
#------------------------------------------------------------------
#    Read VersionNumber attribute
#------------------------------------------------------------------
    def read_VersionNumber(self, attr):
        #self.debug( "In "+self.get_name()+"::read_VersionNumber()")

        #    Add your own code here
        attr_VersionNumber_read = __RELEASE__ #"%s.%s: srubio-2013/07/07"%(MAJOR_VERSION,MINOR_VERSION)
        attr.set_value(attr_VersionNumber_read)
        
#------------------------------------------------------------------
#    Read LastAlarm attribute
#------------------------------------------------------------------
    def read_LastAlarm(self, attr):
        #self.debug( "In "+self.get_name()+"::read_LastAlarm()")

        #    Add your own code here
        attr_LastAlarm_read = ""
        attr_LastAlarm_read = self.LastAlarms.pop(0)
        attr.set_value(attr_LastAlarm_read)

#---- LastAlarm attribute State Machine -----------------
    def is_LastAlarm_allowed(self,req_type=None):
            #if self.get_state() in [PyTango.DevState.INIT]:
            if not self.LastAlarms:
                    #       End of Generated Code
                    #       Re-Start of Generated Code
                    self.info('LastAlarms list is emptied once it is read, is used only for archiving purposes.')
                    PyTango.Except.throw_exception('EmptyList','LastAlarms already read/archived','read_LastAlarm')
                    return False
            return True

#------------------------------------------------------------------
#    Read AlarmConfiguration attribute
#------------------------------------------------------------------
    def read_AlarmConfiguration(self, attr):
        #self.debug("In "+self.get_name()+"::read_AlarmConfiguration()")

        #    Add your own code here
        attr_AlarmConfig_read = []
        attr_AlarmConfig_read = ['%s:%s'%(property,getattr(self,property)) for property in PyAlarmClass.device_property_list.keys() if property not in panic.ALARM_TABLES]
        attr.set_value(attr_AlarmConfig_read)

#------------------------------------------------------------------
#    Read ActiveAlarms attribute
#------------------------------------------------------------------
    def read_ActiveAlarms(self, attr):
        #self.debug( "In "+self.get_name()+"::read_ActiveAlarms()")

        #    Add your own code here
        attr_ActiveAlarms_read = ['%s:%s:%s' % (tag_name,time.ctime(alarm.active),alarm.formula) 
            for tag_name,alarm in self.Alarms.items() if alarm.active][-512:]
        attr.set_value(attr_ActiveAlarms_read, len(attr_ActiveAlarms_read))

#------------------------------------------------------------------
#    Read AcknowledgedAlarms attribute
#------------------------------------------------------------------
    def read_AcknowledgedAlarms(self, attr):
        #self.debug( "In "+self.get_name()+"::read_AcknowledgedAlarms()")

        #    Add your own code here
        attr_AcknowledgedAlarms_read = sorted(self.AcknowledgedAlarms)[-512:]
        attr.set_value(attr_AcknowledgedAlarms_read, len(attr_AcknowledgedAlarms_read))

#------------------------------------------------------------------
#    Read DisabledAlarms attribute
#------------------------------------------------------------------
    def read_DisabledAlarms(self, attr):
        #self.debug( "In "+self.get_name()+"::read_DisabledAlarms()")

        #    Add your own code here
        [self.CheckDisabled(t) for t in self.DisabledAlarms]
        attr_DisabledAlarms_read = sorted('%s until %s'%(a,time.ctime(t)) for a,t in self.DisabledAlarms.items())[-512:]
        attr.set_value(attr_DisabledAlarms_read, len(attr_DisabledAlarms_read))

#------------------------------------------------------------------
#    Read FailedAlarms attribute
#------------------------------------------------------------------
    def read_FailedAlarms(self, attr):
        #self.debug( "In "+self.get_name()+"::read_FailedAlarms()")

        #    Add your own code here
        attr_FailedAlarms_read = self.FailedAlarms.keys()[-512:]
        attr.set_value(attr_FailedAlarms_read, len(attr_FailedAlarms_read))


#------------------------------------------------------------------
#    Read PastAlarms attribute
#------------------------------------------------------------------
    def read_PastAlarms(self, attr):
        #self.debug( "In "+self.get_name()+"::read_PastAlarms()")

        #    Add your own code here
        attr_PastAlarms_read = []
        dates = self.PastAlarms.keys()
        dates.sort(reverse=True)
        for date in dates:
            for tag_name in self.PastAlarms[date]:
                attr_PastAlarms_read.append('%s:%s:%s' % (tag_name,time.ctime(date),self.Alarms[tag_name].formula))
                if len(attr_PastAlarms_read) == 512: break
        #if len(attr_PastAlarms_read)>512: attr_PastAlarms_read = attr_PastAlarms_read[-512:]
        attr.set_value(attr_PastAlarms_read, len(attr_PastAlarms_read))


#------------------------------------------------------------------
#    Read AlarmList attribute
#------------------------------------------------------------------
    def read_AlarmList(self, attr):
        #self.debug( "In "+self.get_name()+"::read_AlarmList()")

        #    Add your own code here
        attr_AlarmList_read = sorted('%s:%s:%s'%(alarm.tag,alarm.description,alarm.formula) for alarm in self.Alarms.values())
        attr.set_value(attr_AlarmList_read, len(self.Alarms))

#------------------------------------------------------------------
#    Read AlarmReceivers attribute
#------------------------------------------------------------------
    def read_AlarmReceivers(self, attr):
        #self.debug( "In "+self.get_name()+"::read_AlarmReceivers()")

        #    Add your own code here
        attr_AlarmReceivers_read = sorted('%s:%s'%(k,v.receivers) for k,v in self.Alarms.items())
        attr.set_value(attr_AlarmReceivers_read, len(attr_AlarmReceivers_read))


#------------------------------------------------------------------
#    Read PhoneBook attribute
#------------------------------------------------------------------
    def read_PhoneBook(self, attr):
        #self.debug( "In "+self.get_name()+"::read_PhoneBook()")

        #    Add your own code here
        attr_PhoneBook_read = sorted('%s:%s'%(k,v) for k,v in self.AddressList.items() if v)
        attr.set_value(attr_PhoneBook_read, len(attr_PhoneBook_read))        


#------------------------------------------------------------------
#    Read SentEmails attribute
#------------------------------------------------------------------
    def read_SentEmails(self, attr):
        #self.debug( "In "+self.get_name()+"::read_SentEmails()")

        #    Add your own code here
        attr_SentEmails_read = []
        for key,value in self.SentEmails.items():
            attr_SentEmails_read.append(key)
            attr_SentEmails_read.append(str(value))
        self.info( 'SentEmails are: %s'%attr_SentEmails_read)
        attr.set_value(attr_SentEmails_read, 2, len(attr_SentEmails_read)/2)


#------------------------------------------------------------------
#    Read SentSMS attribute
#------------------------------------------------------------------
    def read_SentSMS(self, attr):
        self.debug( "In "+self.get_name()+"::read_SentSMS()")

        #    Add your own code here
        attr_SentSMS_read = []
        for key,value in self.SentSMS.items():
            attr_SentSMS_read.append(key)
            attr_SentSMS_read.append(str(value))
        self.debug( 'SentSMS are: %s'%attr_SentSMS_read)
        attr.set_value(attr_SentSMS_read, 2, len(attr_SentSMS_read)/2)


#==================================================================
#
#    PyAlarm command methods
#
#==================================================================

#------------------------------------------------------------------
#    EvaluateFormula command:
#
#    Description: Evaluate an Alarm formula
#
#    argin:  DevString    formula to evaluate
#    argout: DevString
#------------------------------------------------------------------
    def EvaluateFormula(self,argin,tag_name=None,as_string=True,lock=False,_locals=None,variables=None):
        """
        This method can be called from both updateAlarms thread or external clients 
        """
        #    Add your own code here
        t0,STATE,VALUE,variables = time.time(),False,None,{} if variables is None else variables
        try:
            if lock: self.lock.acquire()
            # Update Locals (Done here to minimize time in which WorkerProcess is IDLE)
            if argin in self.Alarms: argin,tag_name = self.Alarms[argin].formula,argin
            _locals = _locals or {}
            _locals['TAG'] = tag_name
            _locals = self.update_locals(_locals)
            formula = self.Panic.replace_alarms(argin) #This replace those alarm names that are not in locals()
            varnames = self.Eval.parse_variables(formula,_locals)
            
            self.info('In EvaluateFormula(%s): %d variables from %s'%(tag_name or formula,len(varnames),sorted(set([tuple(v)[0] for v in varnames]))))
            STATE = any((not attribute or attribute.lower().strip() == 'state') for device,attribute,what in varnames)
            RAISE = (STATE and self.RethrowState) or self.RethrowAttribute or fandango.isFalse(self.IgnoreExceptions)
            if not RAISE: RAISE = fandango.NaN if fandango.isNaN(self.IgnoreExceptions) else None
            self.debug('In EvaluateFormula(%s): STATE = %s'%(tag_name or formula,STATE))
            # ALARM EVALUATION
            #####################################################
            if self.worker and tag_name:
                if tag_name in self.Alarms:
                    alarm = self.Alarms[tag_name]
                    self.debug('\tself.worker.get(%s)'%alarm.tag)
                    VALUE = self.worker.get(alarm.tag,None,_raise=RAISE)
                else:
                    STATE = True
                    raise Exception('UNKNOWN ALARM %s!!'%tag_name)
            else:
                VALUE = self.Eval.eval(formula,_raise=RAISE)
            if tag_name:
                variables.update(self.get_last_values(alarm=tag_name,variables=varnames))
            else:
                variables.update(self.Eval.last)
            self.debug(shortstr('%s: %s, Values = %s'%(tag_name or formula,VALUE,variables),512))
        except Exception,e:
            desc = except2str(e)
            if STATE or self.RethrowAttribute: 
                self.warning('-> Exception while checking State alarm %s:'%tag_name + '\n%s'%formula + '\n%s'%(traceback.format_exc()))
            else:
                self.info( '-> Exception while checking alarm %s:\n%s'%(tag_name or formula,traceback.format_exc()))
            if (self.RethrowState and STATE) or self.RethrowAttribute:
                # STATE EXCEPTION: Exceptions in reading of State attributes will trigger alarms
                ###################################################################################
                VALUE = desc or str(e) or 'Exception!' #Must Have a Value!
                #variables = self.get_last_values(alarm=tag_name,variables=variables)
                variables.update({tag_name or 'VALUE':VALUE})
            else:
                if tag_name: self.FailedAlarms[tag_name]=desc
                self.info('-> Exceptions in Non-State attributes (%s) do not trigger Alarm'%(tag_name or formula))
        finally: 
            if lock: self.lock.release()
        if tag_name: self.EvalTimes[tag_name] = time.time()-t0
        return str(VALUE) if as_string else VALUE

#------------------------------------------------------------------
#    ResetAlarm command:
#
#    Description: Reset alarm, it will be removed from active alarms
#
#    argin:  DevVarStringArray    This is used to inform which alarm should be reset and message. If it doesn't exst an error occurs
#    argout: DevVarStringArray    If succeed, returns the list of ActiveAlarms
#------------------------------------------------------------------
    def ResetAlarm(self, argin):
        self.info( "In "+self.get_name()+"::ResetAlarm()")
        #    Add your own code here
        if len(argin)==1: raise Exception('UserMessageRequiredAs2ndArgument')#tag,userMessage = argin[0],''
        else: tag,userMessage = argin[:2]

        argout = self.get_active_alarms() if self.free_alarm(tag, userMessage, message='RESET') else [] 
        return argout

#------------------------------------------------------------------
#    Acknowledge command:
#
#    Description: Acknowledge alarm no more reminders will be sent
#
#    argin:  DevString    This is used to inform which alarm should be acknowledged. , no more reminders will be sent.
#    argout: DevString    If succeed, returns DONE
#------------------------------------------------------------------
    def Acknowledge(self, argin):
        self.info( "In "+self.get_name()+"::Acknowledge()")
        #    Add your own code here
        if len(argin)==1: tag,userMessage = argin[0],''
        else: tag,userMessage = argin[:2]
        if str(argin[0]) in self.Alarms:
            self.Alarms[str(argin[0])].acknowledged = time.time()
            self.AcknowledgedAlarms.add(str(argin[0]))

        argout = self.get_active_alarms() if self.free_alarm(tag, userMessage, message='ACKNOWLEDGED') else []
        return argout

#------------------------------------------------------------------
#    Renounce command:
#
#    Description: Renounce (opposite to acknowledge) all emails will be send again
#
#    argin:  DevString    This is used to inform which alarm should be renounced.
#    argout: DevString    If succeed, returns DONE
#------------------------------------------------------------------
    def Renounce(self, argin):
        self.info( "In "+self.get_name()+"::Renounce()")
        #    Add your own code here
        argin = str(argin)
        if argin in self.Alarms:
            self.Alarms[argin].acknowledged = 0
            self.AcknowledgedAlarms.remove(argin)
            return 'DONE'
        else: return '%s_NotFound'%argin

#------------------------------------------------------------------
#    Enable command:
#
#    Description: Enable alarm that was put to disable state
#
#    argin:  DevString    This is used to inform which alarm should be enabled.
#    argout: DevString    If succeed, returns DONE
#------------------------------------------------------------------
    def Enable(self, argin):
        self.info( "In "+self.get_name()+"::Enable(%s)"%argin)
        #    Add your own code here
        argin = str(argin)
        if argin in self.Alarms:
            #self.Alarms[argin].active = True
            self.DisabledAlarms.pop(argin)
            return 'DONE'
        else: return '%s_NotFound'%argin

#------------------------------------------------------------------
#    Disable command:
#
#    Description: Disable enabled alarm.
#
#    argin:  DevString    (TAG,comment,[timeout s/m/h/d]) Disable an alarm (skips update loop) until timeout.
#    argout: DevString    If succeed, returns DONE
#------------------------------------------------------------------
    def Disable(self, argin):
        """
        (TAG,comment,[timeout s/m/h/d]) Disable an alarm (skips update loop) until timeout.
        """
        self.info( "In "+self.get_name()+"::Disable(%s)"%argin)
        #    Add your own code here
        args = [(re.match(fun.RAW_TIME,y),y) for x in map(str,argin) for y in map(str.strip,x.split(','))]
        argin = [x[1] for x in args if not x[0]]
        tag,userMessage = argin[0],','.join(argin[1:])
        if tag in self.Alarms:
            self.free_alarm(tag, userMessage, message='DISABLED')
            self.Alarms[str(argin[0])].active = 0
            try: 
                #Setting Disable Timeout
                self.DisabledAlarms[tag] = time.time()+[fun.str2time(x[1]) for x in args if x[0]][0]
            except:
                self.DisabledAlarms[tag] = 0
            return 'DONE'
        else: 
            raise Exception('%s_NotFound'%argin)

#------------------------------------------------------------------
#    CheckDisabled command:
#
#    Description: Check if the alarm is on DisabledAlarms list.
#
#    argin:  DevString    This is used to inform which alarm should be checked.
#    argout: DevBoolean   True if alarm is disabled else False    
#------------------------------------------------------------------
    def CheckDisabled(self, argin):
        #self.debug( "In "+self.get_name()+"::CheckDisabled(%s)"%argin)
        #    Add your own code here
        argin = str(argin)
        if argin in self.DisabledAlarms: 
            if 0<self.DisabledAlarms[argin]<time.time(): 
                self.info('\tReenabling %s after timeout'%argin)
                self.Enable(argin)
                return False
            else:
                return True
        else: return False

#------------------------------------------------------------------
#    CheckAcknowledged command:
#
#    Description: Check if the alarm is on AcknowledgedAlarms list.
#
#    argin:  DevString    This is used to inform which alarm should be checked.
#    argout: DevBoolean   True if alarm is acknowledged else False    
#------------------------------------------------------------------
    def CheckAcknowledged(self, argin):
        self.debug( "In "+self.get_name()+"::CheckAcknowledged()")
        #    Add your own code here
        argin = str(argin)
        if argin in self.AcknowledgedAlarms: return True
        else: return False

#------------------------------------------------------------------
#    ResetAll command:
#
#    Description: Acknowledge alarm that was put into the file with alarms, it will be removed from active alarms
#
#    argin:  DevString    This command requires a user message
#    argout: DevString    If succed, returns the list of ActiveAlarms reseted
#------------------------------------------------------------------
    def ResetAll(self, argin):
        self.info( "In "+self.get_name()+"::ResetAll()")
        #    Add your own code here
        argout = self.get_active_alarms()
        [self.ResetAlarm([key,argin[0]]) for key in argout]
        return 'RESET:'+','.join(argout or ['DONE'])
    
#------------------------------------------------------------------
#    GetRelease command:
#
#    Description: 
#
#    argin:  DevVoid 
#    argout: DevString
#------------------------------------------------------------------
    def GetRelease(self, argin=None):
        self.info( "In "+self.get_name()+"::GetRelease()")
        #    Add your own code here
        return str(__RELEASE__)

#------------------------------------------------------------------
#    AddReceiver command:
#
#    Description: Returns the actual value of AlarmReceivers
#
#    argin:  DevVarStringArray    Attribute,ReceiverAddress
#    argout: DevVarStringArray    Adds a new Receiver to AlarmReceivers property
#------------------------------------------------------------------
    def AddReceiver(self, argin):
        self.info( "In "+ self.get_name()+ "::AddReceiver()")
        #    Add your own code here
        argout = ['FAILED']
        try:
            self.lock.acquire()
            self.Alarms[argin[0]].add_receiver(argin[1])
            argout = ['%s:%s'%(tag,','.join(alarm.receivers)) for tag,alarm in self.Alarms.items()]
        finally:
            self.lock.release()
        return argout

#------------------------------------------------------------------
#    GenerateReport command:
#
#    Description: Generates report message
#
#    argin:  DevVarStringArray    tag,message,receivers,...,description
#    argout: DevVarStringArray
#------------------------------------------------------------------

    def GenerateReport(self,tag_name,mail_receivers='',message='DETAILS',values=None, user_comment=None, html=False):
        """
        When called from Tango a single argument is received; which is a list containing all arguments
        :param message: Can be one of self.MESSAGE_TYPES or a different text
        """
        self.debug( '>'*80)
        #Sending emails
        #-----------------------------------------------------------------------------------------------
        if not mail_receivers and hasattr(tag_name,'__iter__'):
            #This line is executed only when calling from an external Tango client
            tag_name,mail_receivers,message = tag_name[0],tag_name[1:-1],tag_name[-1]
        if fun.isString(mail_receivers):
            mail_receivers = mail_receivers.split(',')

        self.info( 'In GenerateReport(%s,%s,%s)'%(tag_name,mail_receivers,message))
        maillist = []
        alnum = '[a-zA-Z0-9-_.]+'
        email = '(' + alnum + '@' + '(?:' + alnum + r"[\.]" + ')+' + alnum + ')'
        alarm = (self.Alarms.get(tag_name) or [None])[0]
        result = 'FAILED'
        # ( alnum at (non-group-match?: alnum dot)+ alnum ) #: It returns a list with all mail addresses

        for m in mail_receivers:
            addresses = re.findall(email,m)
            self.info( 'in %s, addresses=%s'%(m,addresses))
            [maillist.append(a.lower()) for a in addresses if a.lower() not in maillist]

        #if (maillist or (not maillist and html)):
        report = 'TAG: %s'%tag_name
        actives = self.get_active_alarms()
        subject = '%s %s'%(tag_name,message)
        values = values or self.PastValues.get(tag_name,None)

        if message in ('DETAILS',tag_name):
            first_row = ''
            if self.Alarms[tag_name].active:
                if self.Alarms[tag_name].recovered:
                    first_row += '\n\t' + 'Alarm conditions recovered at %s'%(time.ctime(self.Alarms[tag_name].recovered))
                first_row += '\n\t' + 'Alarm ACTIVE since %s'%(time.ctime(self.Alarms[tag_name].active or self.PastAlarms.get(tag_name,0)))
            else:
                first_row = '\n\t' + 'The alarm is not active.'
        elif message in ('ALARM','REMINDER'):
            first_row = '\n\t' + 'Alarm active since %s'%(time.ctime(self.Alarms[tag_name].active or self.PastAlarms.get(tag_name,0)))
        elif message in ('RECOVERED','AUTORESET'):
            first_row = '\n\t' + '%s at %s' %(message,time.ctime())
        elif message in ('ACKNOWLEDGED','RESET','DETAILS','DISABLED'):
            first_row = '\n\t' + '%s at %s' %(message,time.ctime())
            first_row += '\n\tDetails -> %s'%user_comment
        elif message not in self.MESSAGE_TYPES:
            first_row = '\n\t%s'%message

        report += first_row
        report += '\n\tAlarmDevice: %s'%self.get_name()
        report += '\n\tDescription: %s'%self.Alarms[tag_name].parse_description()
        report += '\n\tSeverity: %s'%self.Alarms[tag_name].parse_severity()
        report += '\n\tFormula: %s'%(self.Alarms[tag_name].formula)
        if values:
            report += '\n\n' + 'Values are: \n'
            if hasattr(values,'items'):
                try: 
                    #report += ('\n\t'.join('%s:\t%s'%(k if not self.Panic.findChild(k) else '<a href="%s.html">%s</a>'%(k.split('/')[-1],k),v) for k,v in sorted(values.items())))
                    for k,v in sorted(values.items(),key=lambda t:(t[-1],t[0])):
                        if any(k.lower().endswith('/%s'%s.lower()) for s in self.Panic.keys()): k = k.split('/')[-1]
                        elif k.lower().endswith('/state'): v = str(PyTango.DevState.values.get(v,v))
                        elif fun.isSequence(v) and len(v) and fun.isString(v[0]): v = ';\n\t'.join(v)
                        report+='\t%s:\t%s'%(k,v) + '\n'
                except: 
                    msg = traceback.format_exc()
                    report += str(values).strip() or msg
                    self.error('Error parsing values for email:\n%s'%msg)
            else: report+= str(values).strip()
        report += '\n\n' + 'EvalTimes are: \n %s\n'%(self.EvalTimes)
        if maillist and len(maillist)>1:
            report += '\n\n' + 'Alarm receivers are: ' + '\n\t'.join([''] + maillist)
        if len(actives) > 1:
            try: report+= '\n\n' + 'Other Active Alarms are:' + '\n\t'.join([''] + sorted(['%s:%s:%s'%(k,time.ctime(v.active),self.Alarms[k].formula) for k,v in self.Alarms.items() if v.active]))
            except: pass
        if self.PastAlarms:
            self.info( self.PastAlarms)
            report+= '\n\n' + 'Past Alarms were:' + '\n\t'.join([''] + ['%s:%s'%(','.join(k),time.ctime(d)) for d,k in self.PastAlarms.items()])
        if html:
            result = [report, subject]
        else:
            result = [report, subject, ','.join(maillist)]
        #else:
            #self.warning( 'The mailing list for %s is empty!'%tag_name)
        self.info( 'Out of GenerateReport(%s,%s,%s)'%(tag_name,mail_receivers,message))
        self.info( '>'*80)
        return result
        
#------------------------------------------------------------------
#    CreateAlarmContext command:
#
#    Description: Creates an Snap context for this Alarm
#
#    argin:  DevVarStringArray    tag,attributes
#    argout: DevLong              new context id
#------------------------------------------------------------------
    def CreateAlarmContext(self, argin):
        tag_name,existingAttrsAllowed = argin[0],argin[1:]
        self.info('In CreateAlarmContext(%s,%s)'%(tag_name,existingAttrsAllowed))
        res=self.snap.db.search_context(tag_name)
        res = sorted(c for c in res if c['reason']=='ALARM')
        cids = [c['id_context'] for c in res]
        if cids:
            self.warning('Cannot create a context - already exist!')
            return cids[0]
        if not existingAttrsAllowed:
            vars = self.Eval.parse_variables(self.Alarms[tag_name].formula)
            existingAttrsAllowed = [str(var[0]+'/'+var[1]) for var in vars if (self.snap.check_attribute_allowed(str(var[0]+'/'+var[1])))]
        if not existingAttrsAllowed:
            self.warning('Cannot create a context - alarm attributes list empty!')
            return -1        
        ctx=self.snap.create_context('AlarmAPP',tag_name,'ALARM',self.Alarms[tag_name].formula,existingAttrsAllowed)
        return ctx.ID

#------------------------------------------------------------------
#    SendMail command:
#
#    Description: Sends a mail message
#
#    argin:  DevVarStringArray    message,subject,receivers
#    argout: DevBoolean
#------------------------------------------------------------------

    def SendMail(self, argin):
        """
        Arguments: message, subject, receivers
        """
        def format4sendmail(report):
            MAX_MAIL_LENGTH = 512
            out = report.replace('\r','\n').replace('\n\n','\n').replace('\n','\\n').replace('"',"'") #.replace("'",'')
            #if len(out)>MAX_MAIL_LENGTH: out = out[:(MAX_MAIL_LENGTH-5)]+'\\n...'
            return out
        try:
            #command = 'echo -e "'+format4sendmail(report)+'" | mail -s "%s" -r %s '%(subject,self.FromAddress) +','.join(maillist)
            command = 'echo -e "'+format4sendmail(argin[0])+'" '
            command += '| mail -s "%s" ' % argin[1]
            command += '-S from=%s ' % self.FromAddress #'-r %s ' % (self.FromAddress)
            command += (argin[2] if fun.isString(argin[2]) else ','.join(argin[2]))
            self.info( 'Launching mail command: '+shortstr(command,512))
            os.system(command)
            for m in argin[2].split(','):
                self.SentEmails[m.lower()]+=1
            return 'DONE'
        except Exception,e:
            self.info( 'Exception in PyAlarm.SendMail(): \n%s'%traceback.format_exc())
        return 'FAILED'

#------------------------------------------------------------------
#    SaveHtml command:
#
#    Description: Saves a html report
#
#    argin:  DevVarStringArray    message,subject
#    argout: DevBoolean
#------------------------------------------------------------------

    def SaveHtml(self, argin):
        def format4html(report):
            out='<pre>'+report+'</pre>'
            return out
        try:
            report=argin[1]+'\n'+argin[0]
            filename=argin[1].split(' ', 2)[1]+'.html'
            f=open(self.HtmlFolder+'/'+filename, 'w')
            report = format4html(report) 
            f.write(report)
            f.close()
            return report
        except Exception,e:
            self.warning( 'Exception in PyAlarm.SaveHtml(): \n%s'%traceback.format_exc())
        return 'FAILED'

#------------------------------------------------------------------
#    SendSMS command:
#
#    Description: Sends an SMS message
#
#    argin:  DevVarStringArray    tag/message,receivers,...,
#    argout: DevBoolean
#------------------------------------------------------------------

    def SendSMS(self,tag,receivers=[],message='TEST',values=None):
        """
        Sending sms, completely dependent of your personal SMS configuration.
        :param tag_name:    Alarm or Test message to be sent
        :param receivers:   SMS numbers to receive the alarm
        """
        if not receivers and hasattr(tag,'__iter__'):
            tag,receivers = tag[0],tag[1:]
        alarm = self.Alarms.get(tag,None)

        self.info( 'In SendSMS(%s,%s,%s,%s)'%(tag,receivers,message,values))
        if not SMS_ALLOWED or not 'smslib' in globals():
            self.warning( 'SMS Messaging is not allowed or smslib not available!!!')
            return
        report = ''
        username,password=self.SMSConfig.split(':',1)
        source = self.FromAddress 
        MAX_SMS_LENGTH=160
        now = time.time()
        try:
            self.lock.acquire()
            while self.SMS_Sent and self.SMS_Sent[0]<now-(24*60*60): self.SMS_Sent.popleft()
            sends = len(self.SMS_Sent)
        finally:
            self.lock.release()
        if sends>=self.MAX_SMS_DAY:
            self.warning( 'The limit of Daily SMS messages (%d) has been exceeded!' % self.MAX_SMS_DAY)
            return
        elif receivers:
            sms = '((SMS:)?([\+]?[0-9]{9,13}))'
            smslist = []
            for s in receivers:
                numbers = re.findall(sms,s)
                [smslist.append(t[-1]) for t in numbers if t and len(t)>1]
                smslist = list(set(smslist))
            if smslist:
                try:
                    self.lock.acquire()
                    self.info( 'SMS Sending: the phone numbers to be reported for %s are: %s' % (tag,','.join(smslist)) )
                    if message in ('ALARM',) and tag in self.Alarms:
                      formula,text = self.Alarms[tag].formula, ';%s'%self.Alarms[tag].parse_description()
                    else:
                        formula,text = '',';%s'%message
                    report = 'Alarm '+tag+': '+text
                    if values: report += ';Values=' + str(values).replace('{','').replace('}','')[:MAX_SMS_LENGTH-len(report)-1]
                    #for sms in smslist: #For unknown reasons it fails when passing a list of numbers
                    self.info( 'SMS Sending: message is: %s' % (report))
                except:
                    self.warning( 'Exception generating SMS report: %s' % traceback.format_exc())
                finally:
                    self.lock.release()

                if 'sms' not in self.AlertOnRecovery.lower() and message.strip() not in ('ALARM','TEST'):
                    self.warning('SMS sending not allowed for %s message type.'%message)
                else:
                    #To avoid device hungs all SMS messages are sent in a background thread
                    if not hasattr(self,'sms_threads'): self.sms_threads = 0
                    self.sms_threads += 1
                    self.info( 'Sending SMS in a different Thread ... '+'SMS-Send%d'%self.sms_threads)
                    source = (re.findall('[a-zA-Z]+',str(source)) or [''])[0]
                    thr = smslib.SMSThread(message=report, dest=smslist, username=username, password=password, source=source)
                    thr.setDaemon(True)
                    thr.start()
                    self.SMS_Sent.append(now)
                    self.info( '%d SMS messages sent in the last 24 hours.' % len(self.SMS_Sent))
                    for s in smslist:
                        self.SentSMS[s.lower()]+=1
                return 'DONE'
        return 'FAILED'

#==================================================================
#
#    PyAlarmClass class definition
#
#==================================================================
#class PyAlarmClass(PyTango.PyDeviceClass):
class PyAlarmClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        'PhoneBook':
            [PyTango.DevVarStringArray,
            "List of alarms declared like:. User:user@accelerator.es;SMS:+34666555666",
            [] ],
        'SMSConfig':
            [PyTango.DevString,
            "Arguments for sendSMS command",
            [ ":" ] ],
        'FromAddress':
            [PyTango.DevString,
            "Address that will appear as Sender in mail and SMS",
            [ "oncall" ] ],
        'AllowedActions':
            [PyTango.DevVarStringArray,
            "List of OS commands that alarms are able to execute.",
            [] ],
        'StartupDelay':
            [PyTango.DevLong,
            "Number of seconds that PyAlarm will wait before starting to evaluate alarms.",
            [ 60 ] ],
        }

    #    Device Properties
    device_property_list = {
        # Alarm Properties: This properties will be managed by API; DON'T ACCESS THEM WITH self.
        'AlarmList':
            [PyTango.DevVarStringArray,
            "List of alarms to be monitorized. The format is:\n<br>domain/family/member #It simply checks that dev is alive\n<br>domain/family/member/attribute > VALUE\n<br>domain/family/member/State == UNKNOWN\n<br>domain/family/*/Temperature > VALUE\n<br>\n<br>When using wildcards all slash / must be included",
            [] ],
        'AlarmReceivers':
            [PyTango.DevVarStringArray,
            "Users that will be notified for each alarm. The format is:\n<br>[TYPE]:[ADDRESS]:[attributes];...\n<br>\n<br>[TYPE]: MAIL / SMS\n<br>[ADDRESS] : operator@accelerator.es / +34666555444\n<br>[attributes]: domain/family/member/attribute;domain/family/*",
            [] ],
        'AlarmDescriptions':
            [PyTango.DevVarStringArray,
            "Description to be included in emails for each alarm. The format is:\n<br>TAG:AlarmDescription...",
            [] ],
        'AlarmConfigurations':
            [PyTango.DevVarStringArray,
            "Configuration customization appliable to each alarm. The format is:\n<br>TAG:PAR1=Value1;PAR2=Value2;...",
            [] ],
        'AlarmSeverities':
            [PyTango.DevVarStringArray,
            "ALARM:DEBUG/INFO/WARNING/ERROR #DEBUG alarms will not trigger messages",
            [] ],

        # Configuration Properties: This properties can be accessed as self.Property
        # NOTE THAT THE DEFAULT VALUES OF THESE PROPERTIES WILL BE OVERRIDEN BY panic.DefaultPyAlarmProperties !!!
        'LogFile':
            [PyTango.DevString,
            "File where alarms are logged, like /tmp/alarm_$NAME.log",
            [ "" ] ], #Overriden by panic.DefaultPyAlarmProperties
        'LogLevel':
            [PyTango.DevString,
            "stdout log filter",
            [ "INFO" ] ],#Overriden by panic.DefaultPyAlarmProperties
        'HtmlFolder':
            [PyTango.DevString,
            "File where alarm reports are saved",
            [ "htmlreports" ] ],#Overriden by panic.DefaultPyAlarmProperties
        'AlarmThreshold':
            [PyTango.DevLong,
            "Min number of consecutive Events/Pollings that must trigger an Alarm.",
            [ 3 ] ],#Overriden by panic.DefaultPyAlarmProperties
        'Enabled':
            [PyTango.DevString,
            "If False forces the device to Disabled state and avoids messaging; if INT then it will last only for N seconds after Startup; if a python formula is written it will be used to enable/disable the device",
            [ '120' ] ],#Overriden by panic.DefaultPyAlarmProperties
        'AlertOnRecovery':
            [PyTango.DevString,
            "It can contain 'email' and/or 'sms' keywords to specify if an automatic message must be sent in case of alarm returning to safe level.",
            [ "false" ] ],#Overriden by panic.DefaultPyAlarmProperties
        'FlagFile':
            [PyTango.DevString,
            "File where a 1 or 0 value will be written depending if theres active alarms or not.\n<br>This file can be used by other notification systems.",
            [ "/tmp/alarm_ds.nagios" ] ],#Overriden by panic.DefaultPyAlarmProperties
        'PollingPeriod':
            [PyTango.DevFloat,
            "Periode in SECONDS in which all attributes not event-driven will be polled; @TODO for convenience any value above 300 will be divided by 1000, it must be DEPRECATED in the future.",
            [ 15. ] ],#Overriden by panic.DefaultPyAlarmProperties
        'MaxMessagesPerAlarm':
            [PyTango.DevLong,
            "Max Number of messages to be sent each time that an Alarm is activated/recovered/reset.",
            [ 20 ] ],#Overriden by panic.DefaultPyAlarmProperties
        'FromAddress':
            [PyTango.DevString,
            "Address that will appear as Sender in mail and SMS",
            [ "oncall" ] ],#Overriden by panic.DefaultPyAlarmProperties
        'SMSConfig':
            [PyTango.DevString,
            "Arguments for sendSMS command",
            [ ":" ] ],#Overriden by panic.DefaultPyAlarmProperties
        'UseSnap':
            [PyTango.DevBoolean,
            "If false no snapshots will be trigered (unless specifically added to receivers)",
            [ True ] ],#Overriden by panic.DefaultPyAlarmProperties
        'CreateNewContexts':
            [PyTango.DevBoolean,
            "It enables PyAlarm to create new contexts for alarms if no matching context exists in the database.",
            [ False ] ],#Overriden by panic.DefaultPyAlarmProperties
        'Reminder':
            [PyTango.DevLong,
            "If a number of seconds is set, a reminder mail will be sent while the alarm is still active, if 0 no Reminder will be sent.",
            [ 0 ] ],#Overriden by panic.DefaultPyAlarmProperties
        'AutoReset':
            [PyTango.DevFloat,
            "If a number of seconds is set, the alarm will reset if the conditions are no longer active after the given interval.",
            [ 3600. ] ],#Overriden by panic.DefaultPyAlarmProperties
        'StartupDelay':
            [PyTango.DevLong,
            "Number of seconds that PyAlarm will wait before starting to evaluate alarms.",
            [ 0 ] ],#Overriden by panic.DefaultPyAlarmProperties
        'EvalTimeout':
            [PyTango.DevLong,
            "Timeout for read_attribute calls, in milliseconds .",
            [ 500 ] ],#Overriden by panic.DefaultPyAlarmProperties
        'UseProcess':
            [PyTango.DevBoolean,
            "To create new OS processes instead of threads.",
            [ False ] ],#Overriden by panic.DefaultPyAlarmProperties
        'UseTaurus':
            [PyTango.DevBoolean,
            "Use Taurus to connect to devices instead of plain PyTango.",
            [ False ] ],#Overriden by panic.DefaultPyAlarmProperties
        'RethrowState':
            [PyTango.DevBoolean,
            "Whether exceptions in State reading will activate the Alarm.",
            [ True ] ],#Overriden by panic.DefaultPyAlarmProperties
        'RethrowAttribute':
            [PyTango.DevBoolean,
            "Whether exceptions in Attribute reading will activate the Alarm.",
            [ False ] ],#Overriden by panic.DefaultPyAlarmProperties
        'IgnoreExceptions':
            [PyTango.DevString,
            "Value can be False/True/NaN to return Exception, None or NotANumber in case of read_attribute exception.",
            [ 'True' ] ],#Overriden by panic.DefaultPyAlarmProperties
        }

    #    Command definitions
    cmd_list = {
        'AddReceiver':
            [[PyTango.DevVarStringArray, "Attribute,ReceiverAddress"],
            [PyTango.DevVarStringArray, "AlarmReceivers values"],
            {
                #'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'EvaluateFormula':
            [[PyTango.DevString, "alarm formula to test with the current environment"],
            [PyTango.DevString,"result obtained"]],
        'ResetAlarm':
            [[PyTango.DevVarStringArray, "This is used to inform which alarm should be reset. If it doesn't exst an error occurs, comment"],
            [PyTango.DevVarStringArray, "If succeed, returns the list of ActiveAlarms"]],
        'Acknowledge':
            [[PyTango.DevVarStringArray, "This is used to inform which alarm should be acknowledged, no more reminders will be sent, comment"],
            [PyTango.DevVarStringArray, "If succeed, returns the list of ActiveAlarms"]],
        'Renounce':
            [[PyTango.DevString, "This is used to inform which alarm should be renounced, all reminders will be send again."],
            [PyTango.DevString, "If succeed, returns DONE"]],
        'Enable':
            [[PyTango.DevString, "(TAG,) This is used to inform which alarm should be enabled, alarm won't skip the updateAlarms loop"],
            [PyTango.DevString, "If succeed, returns DONE"]],
        'Disable':
            [[PyTango.DevVarStringArray, "(TAG,comment,[timeout s/m/h/d]) Disable an alarm (skips update loop) until timeout"],
            [PyTango.DevString, "If succeed, returns DONE"]],
        'ResetAll':
            [[PyTango.DevVarStringArray, "User message"],
            [PyTango.DevString, ""]],
        'GetRelease':
            [[PyTango.DevVoid, ""],
            [PyTango.DevString, ""]],
        'GenerateReport':
            [[PyTango.DevVarStringArray, "tag,message,receivers,...,description"],
            [PyTango.DevVarStringArray,"result, subject, receivers"]],
        'CreateAlarmContext':
            [[PyTango.DevVarStringArray, "tag,attributes,..."],
            [PyTango.DevLong,"new context ID"]],
        'SendMail':
            [[PyTango.DevVarStringArray, "message,subject,receivers"],
            [PyTango.DevString,""]],
        'SaveHtml':
            [[PyTango.DevVarStringArray, "message,subject"],
            [PyTango.DevString,""]],
        'SendSMS':
            [[PyTango.DevVarStringArray, "tag/message,receivers,..."],
            [PyTango.DevString,""]],
        'CheckAcknowledged':
            [[PyTango.DevString, "alarm tag"],
            [PyTango.DevBoolean,"true if alarm is on the list else false"]],
        'CheckDisabled':
            [[PyTango.DevString, "alarm tag"],
            [PyTango.DevBoolean,"true if alarm is on the list else false"]],
        }

    #    Attribute definitions
    attr_list = {
        'VersionNumber':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'Display level':PyTango.DispLevel.EXPERT,
                'description':"Version number and release note",
            } ],
        'LastAlarm':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'Display level':PyTango.DispLevel.EXPERT,
                'description':"Returns Alarm:AlarmDate for last alarms until each is read once, then it's cleared (used for archiving)",
            } ],
        'AlarmConfiguration':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'Display level':PyTango.DispLevel.EXPERT,
                'description':"Returns Property:Value list",
            } ],
        'ActiveAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'description':"Retrieves a list of Active Alarms showing AlarmDate:AlarmDescription",
            } ],
        'PastAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'description':"Returns AlarmDate:ACKDate:AlarmDescription for all OLD alarms already acknowledged",
            } ],
        'AlarmList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'description':"Returns the content of the AlarmList property",
            } ],
        'AlarmReceivers':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'description':"Returns the content of the AlarmReceivers property",
            } ],
        'PhoneBook':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512]],
        'SentEmails':
            [[PyTango.DevString,
            PyTango.IMAGE,
            PyTango.READ, 512,512]],
        'SentSMS':
            [[PyTango.DevString,
            PyTango.IMAGE,
            PyTango.READ, 512,512]],
        'AcknowledgedAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512]],
        'DisabledAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512]],
        'FailedAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512]],
        }

    def dyn_attr(self,dev_list):
        print ( '>'*40)
        print ("In PyAlarmClass.dyn_attr(%s)"%sorted(dev_list))
        for dev in sorted(dev_list):
            print ("In PyAlarmClass.dyn_attr(%s)"%dev)
            dev.dyn_attr()

#------------------------------------------------------------------
#    PyAlarmClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        print ( "In PyAlarmClass  constructor")
        import panic
        for k in panic.PyAlarmDefaultProperties:
            PyAlarmClass.device_property_list[k][-1] = panic.PyAlarmDefaultProperties[k][-1]
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);

#==================================================================
#
#    PyAlarm class main method
#
#==================================================================

def main(args=None):
    import sys
    if args is None:
        args = sys.argv
    try:
        py = PyTango.Util(args)
        py.add_TgClass(PyAlarmClass,PyAlarm,'PyAlarm')
        import sys
        from fandango.device import DDebug
        DDebug.addToServer(py,'PyAlarm',args[1])
        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e    
  
if __name__ == '__main__':
    main(sys.argv)
