# Write output files after running entirety of redmonster
#
# Tim Hutchinson, University of Utah, August 2014
#
# Edited to reflect changes made to zfitter and zpicker, July 2015
# t.hutchinson@utah.edu

import numpy as n
from astropy.io import fits
from os import environ, makedirs, getcwd, remove
from os.path import exists, join, basename
from astropy.io import fits
from time import gmtime, strftime
from glob import iglob
import re

def read_ndArch(fname):
    """
        Read in an ndArch archetype file, parsing parameter baselines.
        (See ndArch data model document for file details.)
        
        Written by A. Bolton, U. of Utah (at IAC), May 2014
        
        Returns the tuple:
        (data, baselines, infodict)
        
        where
        
        data is an array containing archetype templates with
        shape (N_0, N_1,...,N_(npar-1),N_wave)
        
        baselines is a list containing the parameter baseline
        vectors along each of the parameter axes as numpy arrays
        
        infodict is a dictionary with the following keys:
        'filename': archetype source filename (w/o path)
        'class': archetype class taken from filename
        'version': archetype version taken from filename
        'coeff0': log10 Angstroms of the zeroth wavelength pixel
        'coeff1': delta-log10-Angstrom gridding in wavelength
        'nwave': number of pixels in the wavelength dimension
        'fluxunit': unit of archetype fluxes, if specified in file
        'par_names': names of parameter axes, if specified in file
        'par_units': units of parameter axes, if specified in file
        'par_axistype': baseline specification for each axis, from:
        'regular' (regular numerical gridding)
        'irregular' (irregular numerical gridding)
        'labeled' (string-labeled physical parameter gridding)
        'named' (arbitrary string-named objects)
        'index' (one-based index: default if no other spec)
        """
    # Test file generated by test_ndArch.py:
    # fname = 'ndArch-TEST-v00.fits'
    # Parse class and version from the filename:
    fn_ROOT = fname[:fname.rfind('.fits')]
    fn_CLASS = fn_ROOT.split('-')[-2]
    fn_VERSION = fn_ROOT.split('-')[-1]
    # Get the data and header:
    data = fits.getdata(fname).copy()
    header = fits.getheader(fname)
    # Identify how many parameters:
    npars = len(data.shape) - 1
    emptyparlist = ['']
    # Initialize output info dictionary:
    infodict = {'filename': fname.split('/')[-1],
        'class': fn_CLASS,
        'version': fn_VERSION,
        'coeff0': header['CRVAL1'],
        'coeff1': header['CDELT1'],
        'nwave': header['NAXIS1'],
        'fluxunit': '',
        'par_names': ['']*npars,
        'par_units': ['']*npars,
        'par_axistype': ['index']*npars}
    if ('BUNIT' in header): infodict['fluxunit'] = header['BUNIT']
    # Initialize list of baselines with index defaults:
    baselines = [n.arange(this_size)+1 for this_size in data.shape[:-1]]
    # Loop over parameters and construct baselines:
    for ipar in xrange(npars):
        # Translate Python axis index integer to FITS axis index string:
        ax = str(npars + 1 - ipar)
        # Populate name & units for this axis, if available:
        if ('CNAME'+ax in header): infodict['par_names'][ipar] = header['CNAME'+ax]
        if ('CUNIT'+ax in header): infodict['par_units'][ipar] = header['CUNIT'+ax]
        # The axis condition tests -- maybe inefficient to always compute
        # all of these, but makes for nicer code:
        is_regular = ('CRPIX'+ax in header) and \
            ('CRVAL'+ax in header) and \
            ('CDELT'+ax in header)
        pv_base = ['PV'+ax+'_'+str(j+1) for j in xrange(data.shape[ipar])]
        pv_test = n.asarray([this_pv in header for this_pv in pv_base])
        is_irregular = pv_test.prod() > 0
        ps_base = ['PS'+ax+'_'+str(j+1) for j in xrange(data.shape[ipar])]
        ps_test = n.asarray([this_ps in header for this_ps in ps_base])
        is_labeled = ps_test.prod() > 0
        n_base = ['N'+ax+'_'+str(j+1) for j in xrange(data.shape[ipar])]
        n_test = n.asarray([this_n in header for this_n in n_base])
        is_named = n_test.prod() > 0
        if is_regular:
            baselines[ipar] = (n.arange(data.shape[ipar]) + 1 - header['CRPIX'+ax]) \
                * header['CDELT'+ax] + header['CRVAL'+ax]
            infodict['par_axistype'][ipar] = 'regular'
        elif is_irregular:
            baselines[ipar] = n.asarray([header[this_pv] for this_pv in pv_base])
            infodict['par_axistype'][ipar] = 'irregular'
        elif is_labeled:
            baselines[ipar] = n.asarray([header[this_ps] for this_ps in ps_base])
            infodict['par_axistype'][ipar] = 'labeled'
        elif is_named:
            baselines[ipar] = n.asarray([header[this_n] for this_n in n_base])
            infodict['par_axistype'][ipar] = 'named'
    return data, baselines, infodict

# write_ndArch.py
#
# Code for writing ndArch files
#
# bolton@utah@iac 2014mayo
#

def write_ndArch(data, baselines, infodict):
    """
        Write archetype spectrum grid data to and ndArch file.
        (See ndArch data model document for file details.)
        
        Written by A. Bolton, U. of Utah (at IAC), May 2014
        
        Arguments are as follows:
        
        data is an array containing archetype templates with
        shape (N_0, N_1,...,N_(npar-1),N_wave)
        
        baselines is a list containing the parameter baseline
        arrays along each of the parameter axes.
        
        infodict is a dictionary with the following REQUIRED keys:
        'filename': archetype output filename (WITH path, as needed!!);
        to conform, must be of the form ndArch-CLASS-VERSION.fits
        'coeff0': log10 Angstroms of the zeroth wavelength pixel
        'coeff1': delta-log10-Angstrom gridding in wavelength
        'par_axistype': baseline specification for each axis, from:
        'regular' (regular numerical gridding)
        'irregular' (irregular numerical gridding)
        'labeled' (string-labeled physical parameter gridding)
        'named' (arbitrary string-named objects)
        'index' (one-based index; default -- need not be explicit)
        
        infodict can also have the following OPTIONAL keywords:
        'fluxunit': unit of archetype fluxes (string)
        'par_names': names of parameter axes (array of strings)
        'par_units': units of parameter axes (array of strings)
        
        *Note* that the 'infodict' entries are all the same as in
        read_ndArch, EXCEPT for 'filename', which behaves slightly
        differently in that it is to include the path for write_ndArch,
        but strips the path for read_ndArch.
        """
    # Initialize the HDU:
    hdu = fits.PrimaryHDU(data)
    # Set the flux units, if they are provided:
    if ('fluxunit' in infodict): hdu.header.set('BUNIT', value=infodict['fluxunit'], comment='Data unit')
    # Work out the number of parameters:
    npars = len(data.shape) - 1
    # Set the keywords for the wavelength baseline:
    hdu.header.set('CNAME1', value='loglam', comment='Axis 1 name')
    hdu.header.set('CUNIT1', value='log10(Angstroms)', comment='Axis 1 unit')
    hdu.header.set('CRPIX1', value=1., comment='Axis 1 reference pixel')
    hdu.header.set('CRVAL1', value=infodict['coeff0'], comment='Axis 1 reference value')
    hdu.header.set('CDELT1', value=infodict['coeff1'], comment='Axis 1 increment')
    # Loop over parameters...
    # Reverse ordering is to get things in FITS header in natural order.
    for ipar in range(npars)[::-1]:
        # Translate Python axis index integer to FITS axis index string:
        ax = str(npars + 1 - ipar)
        # Populate name & units for this axis, if available:
        if ('par_names' in infodict): hdu.header.set('CNAME'+ax, value=infodict['par_names'][ipar], comment='Axis ' + ax + ' name')
        if ('par_units' in infodict): hdu.header.set('CUNIT'+ax, value=infodict['par_units'][ipar], comment='Axis ' + ax + ' unit')
        if (infodict['par_axistype'][ipar].strip() == 'regular'):
            hdu.header.set('CRPIX'+ax, value=1.0, comment='Axis '+ax+' reference pixel')
            hdu.header.set('CRVAL'+ax, value=baselines[ipar][0], comment='Axis '+ax+' reference value')
            hdu.header.set('CDELT'+ax, value=(baselines[ipar][1]-baselines[ipar][0]), comment='Axis '+ax+' increment')
        elif (infodict['par_axistype'][ipar].strip() == 'irregular'):
            pv_base = ['PV'+ax+'_'+str(j+1) for j in xrange(data.shape[ipar])]
            for j in xrange(data.shape[ipar]):
                hdu.header.set(pv_base[j], value=baselines[ipar][j], comment='Axis '+ax+' value at pixel ' + str(j+1))
        elif (infodict['par_axistype'][ipar].strip() == 'labeled'):
            ps_base = ['PS'+ax+'_'+str(j+1) for j in xrange(data.shape[ipar])]
            for j in xrange(data.shape[ipar]):
                hdu.header.set(ps_base[j], value=baselines[ipar][j], comment='Axis '+ax+' label at pixel ' + str(j+1))
        elif (infodict['par_axistype'][ipar].strip() == 'named'):
            n_base = ['N'+ax+'_'+str(j+1) for j in xrange(data.shape[ipar])]
            for j in xrange(data.shape[ipar]):
                hdu.header.set(n_base[j], value=baselines[ipar][j], comment='Axis '+ax+' name at pixel ' + str(j+1))
        else:
            pass
    hdu.writeto(infodict['filename'], clobber=True)



class Write_Redmonster:
    '''
        Class to write output file at the end of running redmonster.
        
        The zpick argument is simply the entire object created by running
        redmonster.physics.zpicker.py . The self.dest argument is a string
        containing the path in which to save the output file.
        
        If no dest argument is given, or the path does not exist, then the write_rm() method
        will default to writing in $REDMONSTER_SPECTRO_REDUX/$RUN2D/pppp/$RUN1D/ .  If the
        necessary environmental variables are also not specified, it will write in
        directory in which it is being run.
        
        The default behavior is to not clobber any older version of the output file in the
        given directory.  Setting clobber=True will overwrite old versions of the output file.
        '''
    def __init__(self, zpick, dest=None, clobber=True):
        self.clobber = clobber
        self.zpick = zpick
        #if dest and exists(dest): self.dest = dest
        if dest is not None:
            if exists(dest):
                self.dest = dest
            else:
                try:
                    makedirs(dest)
                    self.dest = dest
                except:
                    self.dest = None
        else:
            bsr = environ['REDMONSTER_SPECTRO_REDUX']
            run2d = environ['RUN2D']
            run1d = environ['RUN1D']
            if bsr and run2d and run1d:
                testpath = join(bsr, run2d, '%s' % zpick.plate, run1d)
                if exists(testpath):
                    self.dest = testpath
                else:
                    try:
                        makedirs(testpath)
                        self.dest = testpath
                    except:
                        self.dest = None
            else: self.dest = None

    def create_hdulist(self):
        # Get old header, append new stuff
        hdr = self.zpick.hdr
        hdr.extend([('VERS_RM','v0.1.0','Version of redmonster used'),('DATE_RM',strftime("%Y-%m-%d_%H:%M:%S", gmtime()),'Time of redmonster completion'), ('NFIBERS', len(self.zpick.z), 'Number of fibers'), ('NZ', len(self.zpick.z[0]), 'Number of redshifts retained'),('RCHI2TH',self.zpick.threshold,'Reduced chi**2 threshold used')])
        prihdu = fits.PrimaryHDU(header=self.zpick.hdr)
        # Columns for 1st BIN table
        colslist = []
        colslist.append( fits.Column(name='FIBERID', format='J', array=self.zpick.fiberid) )
        colslist.append( fits.Column(name='DOF', format='J', array=self.zpick.dof) )
        if hasattr(self.zpick, 'boss_target1'):
            colslist.append( fits.Column(name='BOSS_TARGET1', format='J', array=self.zpick.boss_target1) )
        if hasattr(self.zpick, 'eboss_target1'):
            colslist.append( fits.Column(name='EBOSS_TARGET1', format='J', array=self.zpick.eboss_target1) )
        for i in xrange(len(self.zpick.z[0])):
            zlist = []
            zerrlist = []
            classlist = []
            subclasslist = []
            minvectorlist = []
            npolylist = []
            fnamelist = []
            npixsteplist = []
            minrchi2list = []
            fslist = []
            for j in xrange(len(self.zpick.z)):
                zlist.append( self.zpick.z[j][i] )
                zerrlist.append( self.zpick.z_err[j][i] )
                classlist.append( self.zpick.type[j][i] )
                subclasslist.append( repr(self.zpick.subtype[j][i]) )
                fnamelist.append( self.zpick.fname[j][i] )
                minvectorlist.append( repr(self.zpick.minvector[j][i]) )
                npolylist.append( self.zpick.npoly[j][i] )
                npixsteplist.append( self.zpick.npixstep[j][i] )
                minrchi2list.append( self.zpick.minrchi2[j][i] )
                fslist.append( repr(self.zpick.fs[j][i]) )
            colslist.append( fits.Column(name='Z%s' % (i+1), format='E', array=zlist) )
            colslist.append( fits.Column(name='Z_ERR%s' % (i+1), format='E', array=zerrlist) )
            colslist.append( fits.Column(name='CLASS%s' % (i+1), format='%iA' % max(map(len,classlist)), array=classlist) )
            colslist.append( fits.Column(name='SUBCLASS%s' % (i+1), format='%iA' % max(map(len,subclasslist)), array=subclasslist) )
            colslist.append( fits.Column(name='FNAME%s' % (i+1), format='%iA' % max(map(len,fnamelist)), array=fnamelist) )
            colslist.append( fits.Column(name='MINVECTOR%s' % (i+1), format='%iA' % max(map(len,minvectorlist)), array=minvectorlist) )
            colslist.append( fits.Column(name='MINRCHI2%s' % (i+1), format='E', array=minrchi2list) )
            colslist.append( fits.Column(name='NPOLY%s' % (i+1), format='J', array=npolylist) )
            colslist.append( fits.Column(name='NPIXSTEP%s' % (i+1), format='J', array=npixsteplist) )
            colslist.append( fits.Column(name='THETA%s' % (i+1), format='%iA' % max(map(len,fslist)), array=fslist) )
        colslist.append( fits.Column(name='ZWARNING', format='J', array=self.zpick.zwarning) )
        colslist.append( fits.Column(name='RCHI2DIFF', format='E', array=self.zpick.rchi2diff) )
        cols = fits.ColDefs(colslist)
        tbhdu = fits.BinTableHDU.from_columns(cols) #tbhdu = fits.new_table(cols)
        # ImageHDU of models
        sechdu = fits.ImageHDU(data=self.zpick.models)
        self.thdulist = fits.HDUList([prihdu, tbhdu, sechdu]) #self.thdulist = fits.HDUList([prihdu, tbhdu])


    def write_fiber(self):
        self.clobber = True # Temporary fix!!
        self.create_hdulist()
        if self.clobber:
            if self.dest is not None:
                self.thdulist.writeto(join(self.dest, '%s' % 'redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0])), clobber=self.clobber)
                print 'Writing redmonster file to %s' % join(self.dest, '%s' % 'redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0]))
            else:
                self.thdulist.writeto('redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0]), clobber=self.clobber)
                print 'Writing redmonster file to %s' % join( getcwd(), 'redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd) )
        else:
            if self.dest is not None:
                if exists(join(self.dest, '%s' % 'redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0]))):
                    self.thdulist.writeto(join(self.dest, '%s' % 'redmonster-%s-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0], strftime("%Y-%m-%d_%H:%M:%S", gmtime()))))
                    print 'Writing redmonster file to %s' % join(self.dest, '%s' % 'redmonster-%s-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0], strftime("%Y-%m-%d_%H:%M:%S", gmtime())))
                else:
                    self.thdulist.writeto(join(self.dest, '%s' % 'redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0])))
                    print 'Writing redmonster file to %s' % join(self.dest, '%s' % 'redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0]))
            else:
                if exists('redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0])):
                    self.thdulist.writeto('redmonster-%s-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0], strftime("%Y-%m-%d_%H:%M:%S", gmtime())))
                    print 'Writing redmonster file to %s' % join( getcwd(), 'redmonster-%s-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0], strftime("%Y-%m-%d_%H:%M:%S", gmtime())))
                else:
                    self.thdulist.writeto('redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0]))
                    print 'Writing redmonster file to %s' % join( getcwd(), 'redmonster-%s-%s-%03d.fits' % (self.zpick.plate, self.zpick.mjd, self.zpick.fiberid[0]))



    def write_plate(self):
        self.create_hdulist()
        
        if self.clobber:
            if self.dest is not None:
                self.thdulist.writeto(join(self.dest, '%s' % 'redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd)), clobber=self.clobber)
                print 'Writing redmonster file to %s' % join(self.dest, '%s' % 'redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd))
            else:
                self.thdulist.writeto('redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd), clobber=self.clobber)
                print 'Writing redmonster file to %s' % join( getcwd(), 'redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd) )
        else:
            if self.dest is not None:
                if exists(join(self.dest, '%s' % 'redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd))):
                    self.thdulist.writeto(join(self.dest, '%s' % 'redmonster-%s-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd, strftime("%Y-%m-%d_%H:%M:%S", gmtime()))))
                    print 'Writing redmonster file to %s' % join(self.dest, '%s' % 'redmonster-%s-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd, strftime("%Y-%m-%d_%H:%M:%S", gmtime())))
                else:
                    self.thdulist.writeto(join(self.dest, '%s' % 'redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd)))
                    print 'Writing redmonster file to %s' % join(self.dest, '%s' % 'redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd))
            else:
                if exists('redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd)):
                    self.thdulist.writeto('redmonster-%s-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd, strftime("%Y-%m-%d_%H:%M:%S", gmtime())))
                    print 'Writing redmonster file to %s' % join( getcwd(), 'redmonster-%s-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd, strftime("%Y-%m-%d_%H:%M:%S", gmtime())))
                else:
                    self.thdulist.writeto('redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd))
                    print 'Writing redmonster file to %s' % join( getcwd(), 'redmonster-%s-%s.fits' % (self.zpick.plate, self.zpick.mjd))


# ---------------------------------------------------------------------------------------------------------


# Combine individual fiber fits files into a single plate file, or combine all plate files into an spAll-like file
# To combine fiber files, create object for a given plate, mjd and call method merge_fibers()
# To create spAll-like file, instantiate with no plate, mjd and call methond merge_plates()
#
# Tim Hutchinson, University of Utah, November 2014
# t.hutchinson@utah.edu

class Merge_Redmonster:
    
    def __init__(self, plate=None, mjd=None, temp=None):
        self.plate = plate
        self.mjd = mjd
        self.temp = temp
    
    
    def merge_fibers(self):
        self.filepaths = []
        self.type = []
        self.subtype = []
        self.fiberid = []
        self.minvector = []
        self.minrchi2 = []
        self.zwarning = []
        self.dof = []
        self.npoly = []
        self.fname = []
        self.npixstep = []
        self.boss_target1 = []
        self.chi2diff = []
        self.models = None
        self.hdr = None
        
        try: topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except: topdir = None
        try: run2d = environ['RUN2D']
        except: run2d = None
        try: run1d = environ['RUN1D']
        except: run1d = None
        fiberdir = join(topdir, run2d, '%s' % self.plate, run1d, 'redmonster-%s-%s-*.fits' % (self.plate, self.mjd)) if topdir and run2d and run1d else None
        
        if fiberdir:
            for path in iglob(fiberdir):
                self.filepaths.append(path)
                fiberfile = basename(path)
                self.fiberid.append( int(fiberfile[22:25]) )
            self.z = n.zeros( (len(self.fiberid),5) )
            self.z_err = n.zeros( self.z.shape )
            try: self.hdr = fits.open( join( environ['BOSS_SPECTRO_REDUX'], environ['RUN2D'], '%s' % self.plate, 'spPlate-%s-%s.fits' % (self.plate,self.mjd) ) )[0].header
            except: self.hdr = fits.Header()
            npix = fits.open( join( environ['BOSS_SPECTRO_REDUX'], environ['RUN2D'], '%s' % self.plate, 'spPlate-%s-%s.fits' % (self.plate,self.mjd) ) )[0].data.shape[1]
            self.models = n.zeros( (self.z.shape[0],npix) )
            self.filepaths.sort()
            self.fiberid.sort()
            for i, path in enumerate(self.filepaths):
                hdu = fits.open(path)
                self.z[i,0] = hdu[1].data.Z1[0]
                self.z[i,1] = hdu[1].data.Z2[0]
                self.z_err[i,0] = hdu[1].data.Z_ERR1[0]
                self.z_err[i,1] = hdu[1].data.Z_ERR2[0]
                self.type.append(hdu[1].data.CLASS1[0])
                self.subtype.append(hdu[1].data.SUBCLASS1[0])
                self.minvector.append(hdu[1].data.MINVECTOR1[0])
                self.zwarning.append(hdu[1].data.ZWARNING[0])
                self.dof.append(hdu[1].data.DOF[0])
                self.npoly.append(hdu[1].data.NPOLY1[0])
                self.fname.append(hdu[1].data.FNAME1[0])
                self.npixstep.append(hdu[1].data.NPIXSTEP1[0])
                self.chi2diff.append(hdu[1].data.RCHI2DIFF[0])
                try:
                    self.boss_target1.append(hdu[1].data.BOSS_TARGET1[0])
                except:
                    pass
                try:
                    self.eboss_target1.append(hdu[1].data.EBOSS_TARGET1[0])
                except:
                    pass
                self.models[i] = hdu[2].data[0]
                #remove(path)
            output = Write_Redmonster(self, clobber=True)
            output.write_plate()


    def merge_plates(self):
        self.type = []
        self.subtype = []
        self.fiberid = []
        self.minvector = []
        self.zwarning = []
        self.dof = []
        self.npoly = []
        self.fname = []
        self.npixstep = []
        self.chi2diff = []
        self.boss_target1 = []
        self.eboss_target1 = []
        self.plates = []
        self.models = n.zeros((1,1))
        self.hdr = fits.Header()
        
        try: topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except: topdir = None
        try: run2d = environ['RUN2D']
        except: run2d = None
        try: run1d = environ['RUN1D']
        except: run1d = None
        platedir = join( topdir, run2d, '*') if topdir and run2d else None
        
        if platedir:
            for path in iglob(platedir):
                self.plates.append( basename(path) )
            self.plates.sort()
            for listitem in self.plates:
                if listitem[-5:] == '.fits': self.plates.remove(listitem)
            self.fiberid = self.plates
            for plate in self.plates:
                print 'Merging plate %s' % plate
                mjds = []
                try:
                    for x in iglob( join( topdir, run2d, '%s' % plate, run1d, 'redmonster-%s-*.fits' % plate) ):
                        if basename(x)[16:21] not in mjds: mjds.append(basename(x)[16:21])
                #if mjds is not basename(x)[16:21]: mjds.append(basename(x)[16:21])
                #else: mjds.append( basename(x)[16:21] )
                except: mjds = None
                if mjds is not [] and mjds is not None:
                    for mjd in mjds:
                        filepath = join( topdir, run2d, str(plate), run1d, 'redmonster-%s-%s.fits' % (plate, mjd))
                        #npix = fits.open( join( environ['BOSS_SPECTRO_REDUX'], environ['RUN2D'], '%s' % plate, 'spPlate-%s-%s.fits' % (plate, mjd) ) )[0].data.shape[1]
                        if exists(filepath):
                            hdu = fits.open(filepath)
                            self.type += hdu[1].data.CLASS.tolist()
                            self.subtype += hdu[1].data.SUBCLASS.tolist()
                            self.minvector += hdu[1].data.MINVECTOR.tolist()
                            self.zwarning += hdu[1].data.ZWARNING.tolist()
                            self.dof += hdu[1].data.DOF.tolist()
                            self.npoly += hdu[1].data.NPOLY.tolist()
                            self.fname += hdu[1].data.FNAME.tolist()
                            self.npixstep += hdu[1].data.NPIXSTEP.tolist()
                            self.chi2diff += hdu[1].data.CHI2DIFF.tolist()
                            try: self.z1 = n.append(self.z1, hdu[1].data.Z1)
                            except: self.z1 = hdu[1].data.Z1
                            try: self.z_err1 = n.append(self.z_err1, hdu[1].data.Z_ERR1)
                            except: self.z_err1 = hdu[1].data.Z_ERR1
                            try: self.z2 = n.append(self.z2, hdu[1].data.Z2)
                            except: self.z2 = hdu[1].data.Z2
                            try: self.z_err2 = n.append(self.z_err2, hdu[1].data.Z_ERR2)
                            except: self.z_err2 = hdu[1].data.Z_ERR2
        self.z = n.zeros( (self.z1.shape[0],2) )
        self.z_err = n.zeros( self.z.shape )
        self.z[:,0] = self.z1
        self.z[:,1] = self.z2
        self.z_err[:,0] = self.z_err1
        self.z_err[:,1] = self.z_err2
        
        output = Write_Redmonster(self)
        output.create_hdulist()
        output.thdulist.writeto( join( topdir, run2d, 'redmonster-all-%s.fits' % run2d), clobber=True)


    def merge_fibers2(self):
        self.filepaths = []
        self.fiberid = []
        self.dof = []
        self.boss_target1 = []
        self.eboss_target1 = []
        self.z1 = []
        self.z_err1 = []
        self.class1 = []
        self.subclass1 = []
        self.fname1 = []
        self.minvector1 = []
        self.minrchi21 = []
        self.npoly1 = []
        self.npixstep1 = []
        self.theta1 = []
        self.z2 = []
        self.z_err2 = []
        self.class2 = []
        self.subclass2 = []
        self.fname2 = []
        self.minvector2 = []
        self.minrchi22 = []
        self.npoly2 = []
        self.npixstep2 = []
        self.theta2 = []
        self.z3 = []
        self.z_err3 = []
        self.class3 = []
        self.subclass3 = []
        self.fname3 = []
        self.minvector3 = []
        self.minrchi23 = []
        self.npoly3 = []
        self.npixstep3 = []
        self.theta3 = []
        self.z4 = []
        self.z_err4 = []
        self.class4 = []
        self.subclass4 = []
        self.fname4 = []
        self.minvector4 = []
        self.minrchi24 = []
        self.npoly4 = []
        self.npixstep4 = []
        self.theta4 = []
        self.z5 = []
        self.z_err5 = []
        self.class5 = []
        self.subclass5 = []
        self.fname5 = []
        self.minvector5 = []
        self.minrchi25 = []
        self.npoly5 = []
        self.npixstep5 = []
        self.theta5 = []
        self.zwarning = []
        self.rchi2diff = []
    
        try: topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except: topdir = None
        try: run2d = environ['RUN2D']
        except: run2d = None
        try: run1d = environ['RUN1D']
        except: run1d = None
        fiberdir = join(topdir, run2d, '%s' % self.plate, run1d, 'redmonster-%s-%s-*.fits' % (self.plate, self.mjd)) if topdir and run2d and run1d else None
        
        if fiberdir:
            for path in iglob(fiberdir):
                self.filepaths.append( path )
                fiberfile = basename( path )
                self.fiberid.append( int(fiberfile[22:25]) )
            try:
                self.hdr = fits.open( join( environ['BOSS_SPECTRO_REDUX'], environ['RUN2D'], '%s' % self.plate, 'spPlate-%s-%s.fits' % (self.plate,self.mjd) ) )[0].header
            except:
                self.hdr = fits.Header()
            npix = fits.open( join( environ['BOSS_SPECTRO_REDUX'], environ['RUN2D'], '%s' % self.plate, 'spPlate-%s-%s.fits' % (self.plate,self.mjd) ) )[0].data.shape[1]
            self.models = n.zeros( (len(self.fiberid),5,npix) )
            self.filepaths.sort()
            self.fiberid.sort()
            haveHeader = False
            for i, path in enumerate(self.filepaths):
                hdu = fits.open(path)
                if not haveHeader:
                    self.hdr = hdu[0].header
                    haveHeader = True
                self.dof.append(hdu[1].data.DOF[0])
                self.z1.append(hdu[1].data.Z1[0])
                self.z_err1.append(hdu[1].data.Z_ERR1[0])
                self.class1.append(hdu[1].data.CLASS1[0])
                self.subclass1.append(hdu[1].data.SUBCLASS1[0])
                self.fname1.append(hdu[1].data.FNAME1[0])
                self.minvector1.append(hdu[1].data.MINVECTOR1[0])
                self.minrchi21.append(hdu[1].data.MINRCHI21[0])
                self.npoly1.append(hdu[1].data.NPOLY1[0])
                self.npixstep1.append(hdu[1].data.NPIXSTEP1[0])
                self.theta1.append(hdu[1].data.THETA1[0])
                self.z2.append(hdu[1].data.Z2[0])
                self.z_err2.append(hdu[1].data.Z_ERR2[0])
                self.class2.append(hdu[1].data.CLASS2[0])
                self.subclass2.append(hdu[1].data.SUBCLASS2[0])
                self.fname2.append(hdu[1].data.FNAME2[0])
                self.minvector2.append(hdu[1].data.MINVECTOR2[0])
                self.minrchi22.append(hdu[1].data.MINRCHI22[0])
                self.npoly2.append(hdu[1].data.NPOLY2[0])
                self.npixstep2.append(hdu[1].data.NPIXSTEP2[0])
                self.theta2.append(hdu[1].data.THETA2[0])
                self.z3.append(hdu[1].data.Z3[0])
                self.z_err3.append(hdu[1].data.Z_ERR3[0])
                self.class3.append(hdu[1].data.CLASS3[0])
                self.subclass3.append(hdu[1].data.SUBCLASS3[0])
                self.fname3.append(hdu[1].data.FNAME3[0])
                self.minvector3.append(hdu[1].data.MINVECTOR3[0])
                self.minrchi23.append(hdu[1].data.MINRCHI23[0])
                self.npoly3.append(hdu[1].data.NPOLY3[0])
                self.npixstep3.append(hdu[1].data.NPIXSTEP3[0])
                self.theta3.append(hdu[1].data.THETA3[0])
                self.z4.append(hdu[1].data.Z4[0])
                self.z_err4.append(hdu[1].data.Z_ERR4[0])
                self.class4.append(hdu[1].data.CLASS4[0])
                self.subclass4.append(hdu[1].data.SUBCLASS4[0])
                self.fname4.append(hdu[1].data.FNAME4[0])
                self.minvector4.append(hdu[1].data.MINVECTOR4[0])
                self.minrchi24.append(hdu[1].data.MINRCHI24[0])
                self.npoly4.append(hdu[1].data.NPOLY4[0])
                self.npixstep4.append(hdu[1].data.NPIXSTEP4[0])
                self.theta4.append(hdu[1].data.THETA4[0])
                self.z5.append(hdu[1].data.Z5[0])
                self.z_err5.append(hdu[1].data.Z_ERR5[0])
                self.class5.append(hdu[1].data.CLASS5[0])
                self.subclass5.append(hdu[1].data.SUBCLASS5[0])
                self.fname5.append(hdu[1].data.FNAME5[0])
                self.minvector5.append(hdu[1].data.MINVECTOR5[0])
                self.minrchi25.append(hdu[1].data.MINRCHI25[0])
                self.npoly5.append(hdu[1].data.NPOLY5[0])
                self.npixstep5.append(hdu[1].data.NPIXSTEP5[0])
                self.theta5.append(hdu[1].data.THETA5[0])
                self.zwarning.append(hdu[1].data.ZWARNING[0])
                self.rchi2diff.append(hdu[1].data.RCHI2DIFF[0])
                try:
                    self.boss_target1.append(hdu[1].data.BOSS_TARGET1[0])
                except:
                    pass
                try:
                    self.eboss_target1.append(hdu[1].data.EBOSS_TARGET1[0])
                except:
                    pass
                self.models[i] = hdu[2].data[0]
                #remove(path)
            self.hdr['NFIBERS'] = len(self.fiberid)
            prihdu = fits.PrimaryHDU(header=self.hdr)
            colslist = []
            colslist.append( fits.Column(name='FIBERID', format='J', array=self.fiberid) )
            colslist.append( fits.Column(name='DOF', format='J', array=self.dof) )
            try: colslist.append( fits.Column(name='BOSS_TARGET1', format='J', array=self.boss_target1) )
            except: pass
            try:colslist.append( fits.Column(name='EBOSS_TARGET1', format='J', array=self.eboss_target1) )
            except: pass
            colslist.append( fits.Column(name='Z1', format='E', array=self.z1) )
            colslist.append( fits.Column(name='Z_ERR1', format='E', array=self.z_err1) )
            colslist.append( fits.Column(name='CLASS1', format='%iA' % max(map(len,self.class1)), array=self.class1) )
            colslist.append( fits.Column(name='SUBCLASS1', format='%iA' % max(map(len,self.subclass1)), array=self.subclass1) )
            colslist.append( fits.Column(name='FNAME1', format='%iA' % max(map(len,self.fname1)), array=self.fname1) )
            colslist.append( fits.Column(name='MINVECTOR1', format='%iA' % max(map(len,self.minvector1)), array=self.minvector1) )
            colslist.append( fits.Column(name='MINRCHI21', format='E', array=self.minrchi21) )
            colslist.append( fits.Column(name='NPOLY1', format='J', array=self.npoly1) )
            colslist.append( fits.Column(name='NPIXSTEP1', format='J', array=self.npixstep1) )
            colslist.append( fits.Column(name='THETA1', format='%iA' % max(map(len,self.theta1)), array=self.theta1) )
            colslist.append( fits.Column(name='Z2', format='E', array=self.z2) )
            colslist.append( fits.Column(name='Z_ERR2', format='E', array=self.z_err2) )
            colslist.append( fits.Column(name='CLASS2', format='%iA' % max(map(len,self.class2)), array=self.class2) )
            colslist.append( fits.Column(name='SUBCLASS2', format='%iA' % max(map(len,self.subclass2)), array=self.subclass2) )
            colslist.append( fits.Column(name='FNAME2', format='%iA' % max(map(len,self.fname2)), array=self.fname2) )
            colslist.append( fits.Column(name='MINVECTOR2', format='%iA' % max(map(len,self.minvector2)), array=self.minvector2) )
            colslist.append( fits.Column(name='MINRCHI22', format='E', array=self.minrchi22) )
            colslist.append( fits.Column(name='NPOLY2', format='J', array=self.npoly2) )
            colslist.append( fits.Column(name='NPIXSTEP2', format='J', array=self.npixstep2) )
            colslist.append( fits.Column(name='THETA2', format='%iA' % max(map(len,self.theta2)), array=self.theta2) )
            colslist.append( fits.Column(name='Z3', format='E', array=self.z3) )
            colslist.append( fits.Column(name='Z_ERR3', format='E', array=self.z_err3) )
            colslist.append( fits.Column(name='CLASS3', format='%iA' % max(map(len,self.class3)), array=self.class3) )
            colslist.append( fits.Column(name='SUBCLASS3', format='%iA' % max(map(len,self.subclass3)), array=self.subclass3) )
            colslist.append( fits.Column(name='FNAME3', format='%iA' % max(map(len,self.fname3)), array=self.fname3) )
            colslist.append( fits.Column(name='MINVECTOR3', format='%iA' % max(map(len,self.minvector3)), array=self.minvector3) )
            colslist.append( fits.Column(name='MINRCHI23', format='E', array=self.minrchi23) )
            colslist.append( fits.Column(name='NPOLY3', format='J', array=self.npoly3) )
            colslist.append( fits.Column(name='NPIXSTEP3', format='J', array=self.npixstep3) )
            colslist.append( fits.Column(name='THETA3', format='%iA' % max(map(len,self.theta3)), array=self.theta3) )
            colslist.append( fits.Column(name='Z4', format='E', array=self.z4) )
            colslist.append( fits.Column(name='Z_ERR4', format='E', array=self.z_err4) )
            colslist.append( fits.Column(name='CLASS4', format='%iA' % max(map(len,self.class4)), array=self.class4) )
            colslist.append( fits.Column(name='SUBCLASS4', format='%iA' % max(map(len,self.subclass4)), array=self.subclass4) )
            colslist.append( fits.Column(name='FNAME4', format='%iA' % max(map(len,self.fname4)), array=self.fname4) )
            colslist.append( fits.Column(name='MINVECTOR4', format='%iA' % max(map(len,self.minvector4)), array=self.minvector4) )
            colslist.append( fits.Column(name='MINRCHI24', format='E', array=self.minrchi24) )
            colslist.append( fits.Column(name='NPOLY4', format='J', array=self.npoly4) )
            colslist.append( fits.Column(name='NPIXSTEP4', format='J', array=self.npixstep4) )
            colslist.append( fits.Column(name='THETA4', format='%iA' % max(map(len,self.theta4)), array=self.theta4) )
            colslist.append( fits.Column(name='Z5', format='E', array=self.z5) )
            colslist.append( fits.Column(name='Z_ERR5', format='E', array=self.z_err5) )
            colslist.append( fits.Column(name='CLASS5', format='%iA' % max(map(len,self.class5)), array=self.class5) )
            colslist.append( fits.Column(name='SUBCLASS5', format='%iA' % max(map(len,self.subclass5)), array=self.subclass5) )
            colslist.append( fits.Column(name='FNAME5', format='%iA' % max(map(len,self.fname5)), array=self.fname5) )
            colslist.append( fits.Column(name='MINVECTOR5', format='%iA' % max(map(len,self.minvector5)), array=self.minvector5) )
            colslist.append( fits.Column(name='MINRCHI25', format='E', array=self.minrchi25) )
            colslist.append( fits.Column(name='NPOLY5', format='J', array=self.npoly5) )
            colslist.append( fits.Column(name='NPIXSTEP5', format='J', array=self.npixstep5) )
            colslist.append( fits.Column(name='THETA5', format='%iA' % max(map(len,self.theta5)), array=self.theta5) )
            colslist.append( fits.Column(name='ZWARNING', format='J', array=self.zwarning) )
            colslist.append( fits.Column(name='RCHI2DIFF', format='E', array=self.rchi2diff) )
            cols = fits.ColDefs(colslist)
            tbhdu = fits.BinTableHDU.from_columns(cols) #tbhdu = fits.new_table(cols)
            # ImageHDU of models
            sechdu = fits.ImageHDU(data=self.models)
            thdulist = fits.HDUList([prihdu, tbhdu, sechdu]) #self.thdulist = fits.HDUList([prihdu, tbhdu])
            
            dest = join(topdir, run2d, '%s' % self.plate, run1d, 'redmonster-%s-%s.fits' % (self.plate, self.mjd))
            thdulist.writeto( dest, clobber=True )


    def merge_plates2(self):
        self.platelist = []
        self.mjdlist = []
        self.fiberid = []
        self.dof = []
        self.boss_target1 = []
        self.eboss_target1 = []
        self.z = []
        self.z_err = []
        self.type = []
        self.subtype = []
        self.fname = []
        self.minvector = []
        self.minrchi2 = []
        self.npoly = []
        self.npixstep = []
        self.theta = []
        self.zwarning = []
        self.rchi2diff = []
        
        self.plates = []
        self.hdr = fits.Header()
        
        try: topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except: topdir = None
        try: run2d = environ['RUN2D']
        except: run2d = None
        try: run1d = environ['RUN1D']
        except: run1d = None
        platedir = join( topdir, run2d, '*') if topdir and run2d else None
        
        if platedir:
            for path in iglob(platedir):
                self.plates.append( basename(path) )
            self.plates.sort()
            for listitem in self.plates:
                if listitem[-5:] == '.fits': self.plates.remove(listitem) # Ignore any existing redmonster-all files
            for plate in self.plates:
                print 'Merging plate %s' % plate
                mjds = []
                try:
                    for x in iglob( join( topdir, run2d, '%s' % plate, run1d, 'redmonster-%s-*.fits' % plate) ):
                        if basename(x)[16:21] not in mjds: mjds.append(basename(x)[16:21])
                except: mjds = None
                if mjds is not [] and mjds is not None:
                    for mjd in mjds:
                        filepath = join( topdir, run2d, '%s' % plate, run1d, 'redmonster-%s-%s.fits' % (plate, mjd))
                        if exists(filepath):
                            hdu = fits.open(filepath)
                            self.fiberid += hdu[1].data.FIBERID.tolist()
                            self.platelist += [plate]*len(hdu[1].data.FIBERID.tolist())
                            self.mjdlist += [mjd]*len(hdu[1].data.FIBERID.tolist())
                            self.dof += hdu[1].data.DOF.tolist()
                            try: self.boss_target1 += hdu[1].data.BOSS_TARGET1.tolist()
                            except: pass
                            try: self.eboss_target1 += hdu[1].data.EBOSS_TARGET1.tolist()
                            except: pass
                            self.z += hdu[1].data.Z1.tolist()
                            self.z_err += hdu[1].data.Z_ERR1.tolist()
                            self.type += hdu[1].data.CLASS.tolist()
                            self.subtype += hdu[1].data.SUBCLASS.tolist()
                            self.fname += hdu[1].data.FNAME.tolist()
                            self.minvector += hdu[1].data.MINVECTOR.tolist()
                            self.minrchi2 += hdu[1].data.MINRCHI2.tolist()
                            self.npoly += hdu[1].data.NPOLY.tolist()
                            self.npixstep += hdu[1].data.NPIXSTEP.tolist()
                            self.theta += hdu[1].data.THETA.tolist()
                            self.zwarning += hdu[1].data.ZWARNING.tolist()
                            self.rchi2diff += hdu[1].data.CHI2DIFF.tolist()
        
            self.hdr['NFIBERS'] = len(self.fiberid)
            prihdu = fits.PrimaryHDU(header=self.hdr)
            colslist = []
            colslist.append( fits.Column(name='FIBERID', format='J', array=self.fiberid) )
            colslist.append( fits.Column(name='DOF', format='J', array=self.dof) )
            try: colslist.append( fits.Column(name='BOSS_TARGET1', format='J', array=self.boss_target1) )
            except: pass
            try:colslist.append( fits.Column(name='EBOSS_TARGET1', format='J', array=self.eboss_target1) )
            except: pass
            colslist.append( fits.Column(name='Z', format='E', array=self.z) )
            colslist.append( fits.Column(name='Z_ERR', format='E', array=self.z_err) )
            colslist.append( fits.Column(name='CLASS', format='%iA' % max(map(len,self.type)), array=self.type) )
            colslist.append( fits.Column(name='SUBCLASS', format='%iA' % max(map(len,self.subtype)), array=self.subtype) )
            colslist.append( fits.Column(name='FNAME', format='%iA' % max(map(len,self.fname)), array=self.fname) )
            colslist.append( fits.Column(name='MINVECTOR', format='%iA' % max(map(len,self.minvector)), array=self.minvector) )
            colslist.append( fits.Column(name='MINRCHI2', format='E', array=self.minrchi2) )
            colslist.append( fits.Column(name='NPOLY', format='J', array=self.npoly) )
            colslist.append( fits.Column(name='NPIXSTEP', format='J', array=self.npixstep) )
            colslist.append( fits.Column(name='THETA', format='%iA' % max(map(len,self.theta)), array=self.theta) )
            colslist.append( fits.Column(name='ZWARNING', format='J', array=self.zwarning) )
            colslist.append( fits.Column(name='RCHI2DIFF', format='E', array=self.rchi2diff) )
            
            cols = fits.ColDefs(colslist)
            tbhdu = fits.BinTableHDU.from_columns(cols)
            thdulist = fits.HDUList([prihdu, tbhdu])
            
            dest = join(topdir, run2d, 'redmonster-all-%s.fits' % run1d)
            thdulist.writeto( dest, clobber=True )


    def merge_chi2(self):
        
        try: topdir = environ['REDMONSTER_SPECTRO_REDUX']
        except: topdir = None
        try: run2d = environ['RUN2D']
        except: run2d = None
        try: run1d = environ['RUN1D']
        except: run1d = None
        chi2path = join( topdir, run2d, '%s' % self.plate, run1d, 'chi2arr-%s-%s-%s-*.fits' % (self.temp, self.plate, self.mjd) ) if topdir and run2d and run1d else None
        
        fiberid = []
        paths = []
        
        if chi2path:
            for file in iglob(chi2path):
                paths.append( file )
                m = re.search( 'chi2arr-%s-%s-%s-(\d+).fits' % (self.temp, self.plate, self.mjd), basename(file) )
                if m.group(1): fiberid.append( int(m.group(1)) )
            fiberid.sort()
            paths.sort()
            
            for i,path in enumerate(paths):
                chi2arr = fits.open(path)[0].data
                try:
                    chi2arrs
                except NameError:
                    chi2arrs = n.zeros( (len(fiberid),) + chi2arr.shape[1:] )
                    chi2arrs[i] = chi2arr
                else:
                    chi2arrs[i] = chi2arr
                remove(path)

            prihdu = fits.PrimaryHDU(chi2arrs)
            col1 = fits.Column(name='FIBERID', format='J', array=fiberid)
            cols = fits.ColDefs([col1])
            tbhdu = fits.BinTableHDU.from_columns(cols)
            thdulist = fits.HDUList([prihdu,tbhdu])
            thdulist.writeto( join( topdir, run2d, '%s' % self.plate, run1d, 'chi2arr-%s-%s-%s.fits' % (self.temp, self.plate, self.mjd) ), clobber=True)


# ------------------------------------------------------------------------------------------------------------------------------


def write_chi2arr(plate, mjd, fiberid, zchi2arr):
    # Write chi**2 surface, called by zfinder
    prihdu = fits.PrimaryHDU(zchi2arr)
    thdulist = fits.HDUList([prihdu])
    try:
        rsr = environ['REDMONSTER_SPECTRO_REDUX']
        run2d = environ['RUN2D']
        run1d = environ['RUN1D']
        if (rsr is not None) & (run2d is not None) & (run1d is not None):
            testpath = join(rsr, run2d, '%s' % plate, run1d)
            if exists(testpath):
                dest = testpath
            else:
                try:
                    makedirs(testpath)
                    dest = testpath
                except:
                    dest = None
    except:
        dest = None
        if dest is not None:
            try:
                thdulist.writeto(join(dest, '%s' % 'chi2arr-%s-%s-%s-%03d.fits' % (self.type, plate, mjd, fiberid)), clobber=True)
                print 'Writing chi2 file to %s' % join(dest, '%s' % 'chi2arr-%s-%s-%s-%03d.fits' % (self.type, plate, mjd, fiberid))
            except:
                print 'Environment variables not set or path does not exist - not writing chi2 file!'
    else:
        print 'Environment variables not set or path does not exist - not writing chi2 file!'


